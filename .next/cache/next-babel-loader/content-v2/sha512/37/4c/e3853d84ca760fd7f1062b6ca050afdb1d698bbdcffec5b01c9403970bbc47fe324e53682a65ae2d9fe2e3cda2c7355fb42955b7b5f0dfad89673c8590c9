{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { APIHandler } from \"src/apiHelpers\";\nimport { getToken } from \"src/token\";\nimport { sendWatchingNotificationEmail } from \"emails\";\nimport { prettyDate } from \"src/utils\";\nimport produce from \"immer\";\nimport { updateCategory, updateGroup } from \"src/discourse\";\nimport prisma from \"lib/prisma\";\nexport default APIHandler({\n  POST: updateCohort,\n  GET: getCohortData\n});\n\nasync function updateCohort(req) {\n  let msg = req.body;\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  if (!msg.data) return {\n    status: 400,\n    result: \"Error: invalid request, missing data\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 400,\n    result: \"ERROR: no user logged in'\"\n  };\n  let cohort = await prisma.course_cohorts.findUnique({\n    where: {\n      id: cohortId\n    },\n    select: {\n      name: true,\n      cohort_facilitators: true,\n      completed: true,\n      live: true,\n      start_date: true,\n      course: true,\n      category_id: true,\n      discourse_groups: true,\n      courses: {\n        select: {\n          name: true,\n          slug: true,\n          description: true\n        }\n      }\n    }\n  });\n  if (!cohort) return {\n    status: 404,\n    result: `No cohort with id ${cohortId} found`\n  };\n  if (!cohort.cohort_facilitators.find(f => user && f.facilitator === user.id)) return {\n    status: 401,\n    result: `ERROR: User is not facilitator of cohort`\n  };\n  let completed;\n\n  if (msg.data.completed && !cohort.completed) {\n    completed = new Date().toISOString();\n  }\n\n  if (msg.data.name && cohort.name !== msg.data.name) {\n    await Promise.all([updateGroup(cohort.discourse_groups.id, cohort.courses.slug + '-' + msg.data.name), updateCategory(cohort.category_id, {\n      name: cohort.courses.slug + '-' + msg.data.name\n    })]);\n  }\n\n  if (cohort.live === false && msg.data.live === true) {\n    // If we're toggling a cohort live, notify those watching\n    let watchers = await prisma.watching_courses.findMany({\n      where: {\n        course: cohort.course\n      },\n      select: {\n        email: true\n      }\n    });\n    await sendWatchingNotificationEmail(watchers.map(watcher => {\n      if (!cohort) return;\n      return {\n        email: watcher.email,\n        Metadata: {\n          type: \"course-watching-notification\",\n          course: cohort.course.toString()\n        },\n        vars: {\n          course_name: cohort.courses.name,\n          cohort_page_url: `https://app.krakenedu.com/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohortId}`,\n          cohort_start_date: prettyDate(cohort.start_date),\n          course_description: cohort.courses.description\n        }\n      };\n    }));\n  }\n\n  let newData = await prisma.course_cohorts.update({\n    where: {\n      id: cohortId\n    },\n    data: {\n      live: msg.data.live,\n      completed,\n      name: msg.data.name,\n      start_date: msg.data.start_date,\n      description: msg.data.description\n    }\n  });\n  if (!newData) return {\n    status: 404,\n    result: `No cohort with id ${cohortId} found`\n  };\n  return {\n    status: 200,\n    result: newData\n  };\n}\n\nexport const cohortDataQuery = async (id, userId) => {\n  let data = await prisma.course_cohorts.findUnique({\n    where: {\n      id\n    },\n    select: {\n      description: true,\n      name: true,\n      category_id: true,\n      start_date: true,\n      id: true,\n      live: true,\n      completed: true,\n      cohort_facilitators: {\n        select: {\n          facilitator: true,\n          people: {\n            select: {\n              display_name: true,\n              username: true,\n              bio: true,\n              pronouns: true\n            }\n          }\n        }\n      },\n      people: {\n        select: {\n          display_name: true,\n          username: true,\n          bio: true,\n          pronouns: true\n        }\n      },\n      cohort_events: {\n        include: {\n          events: {\n            include: {\n              people_in_events: {\n                select: {\n                  people: {\n                    select: {\n                      username: true,\n                      display_name: true,\n                      id: true\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      courses: {\n        select: {\n          name: true,\n          card_image: true,\n          cohort_max_size: true,\n          id: true,\n          type: true,\n          slug: true,\n          cost: true,\n          duration: true,\n          description: true,\n          category_id: true\n        }\n      },\n      people_in_cohorts: {\n        include: {\n          people: {\n            select: {\n              display_name: true,\n              pronouns: true,\n              username: true,\n              email: true\n            }\n          }\n        }\n      }\n    }\n  });\n  if (!data) return;\n  let enrolled = data.people_in_cohorts.find(x => x.person === userId);\n  let isFacilitator = data.cohort_facilitators.find(f => f.facilitator === userId);\n  let cohort_events = data.cohort_events.filter(c => c.everyone || isFacilitator || enrolled && c.events.people_in_events.find(p => p.people.id === userId)).map(event => produce(event, e => {\n    if (!enrolled && !isFacilitator) e.events.location = '';\n  }));\n  let people_in_cohorts = data.people_in_cohorts.map(person => produce(person, p => {\n    if (!isFacilitator) p.people.email = '';\n  }));\n  return _objectSpread(_objectSpread({}, data), {}, {\n    cohort_events,\n    people_in_cohorts\n  });\n};\n\nasync function getCohortData(req) {\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  let data = await cohortDataQuery(cohortId, user === null || user === void 0 ? void 0 : user.id);\n  if (!data) return {\n    status: 404,\n    result: `Error: no cohort with id ${cohortId} found`\n  };\n  return {\n    status: 200,\n    result: data\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/cohorts/[cohortId]/index.ts"],"names":["APIHandler","getToken","sendWatchingNotificationEmail","prettyDate","produce","updateCategory","updateGroup","prisma","POST","updateCohort","GET","getCohortData","req","msg","body","cohortId","parseInt","query","Number","isNaN","status","result","data","user","cohort","course_cohorts","findUnique","where","id","select","name","cohort_facilitators","completed","live","start_date","course","category_id","discourse_groups","courses","slug","description","find","f","facilitator","Date","toISOString","Promise","all","watchers","watching_courses","findMany","email","map","watcher","Metadata","type","toString","vars","course_name","cohort_page_url","cohort_start_date","course_description","newData","update","cohortDataQuery","userId","people","display_name","username","bio","pronouns","cohort_events","include","events","people_in_events","card_image","cohort_max_size","cost","duration","people_in_cohorts","enrolled","x","person","isFacilitator","filter","c","everyone","p","event","e","location"],"mappings":"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","sourcesContent":["import { ResultType, APIHandler, Request } from \"src/apiHelpers\"\nimport { getToken } from \"src/token\"\nimport { sendWatchingNotificationEmail } from \"emails\"\nimport { prettyDate } from \"src/utils\"\nimport produce from \"immer\"\nimport { updateCategory, updateGroup } from \"src/discourse\"\nimport prisma from \"lib/prisma\";\n\nexport type UpdateCohortMsg = {\n  data: Partial<{\n    completed: true\n    live: boolean\n    start_date: string,\n    name: string,\n    description: string\n  }>\n}\n\nexport type UpdateCohortResponse = ResultType<typeof updateCohort>\nexport type CohortResult = ResultType<typeof getCohortData>\n\nexport default APIHandler({POST: updateCohort, GET: getCohortData})\nasync function updateCohort(req:Request) {\n  let msg = req.body as Partial<UpdateCohortMsg>\n  let cohortId = parseInt(req.query.cohortId as string)\n  if(Number.isNaN(cohortId)) return {status: 400, result: \"ERROR: Cohort id is not a number\"} as const\n\n  if(!msg.data) return {status: 400, result: \"Error: invalid request, missing data\"} as const\n\n  let user = getToken(req)\n  if(!user) return {status: 400, result: \"ERROR: no user logged in'\"} as const\n  let cohort = await prisma.course_cohorts.findUnique({\n    where:{id:cohortId},\n    select: {\n      name: true,\n      cohort_facilitators: true,\n      completed: true,\n      live: true,\n      start_date: true,\n      course: true,\n      category_id: true,\n      discourse_groups: true,\n      courses: {\n        select: {\n          name: true,\n          slug: true,\n          description: true\n        }\n      }\n    }})\n  if(!cohort) return {status: 404, result: `No cohort with id ${cohortId} found`} as const\n  if(!cohort.cohort_facilitators.find(f=>user&&f.facilitator===user.id)) return {status:401, result:`ERROR: User is not facilitator of cohort`} as const\n\n  let completed\n  if(msg.data.completed && !cohort.completed) {\n    completed = (new Date()).toISOString()\n  }\n\n  if(msg.data.name && cohort.name !== msg.data.name) {\n    await Promise.all([\n      updateGroup(cohort.discourse_groups.id, cohort.courses.slug+'-'+msg.data.name),\n      updateCategory(cohort.category_id, {name: cohort.courses.slug+'-'+msg.data.name})\n    ])\n  }\n\n  if(cohort.live === false && msg.data.live === true) {\n    // If we're toggling a cohort live, notify those watching\n    let watchers = await prisma.watching_courses.findMany({\n      where: {course: cohort.course},\n      select: {email: true}\n    })\n    await sendWatchingNotificationEmail(watchers.map(watcher => {\n      if(!cohort) return\n      return {\n        email: watcher.email,\n        Metadata: {\n          type: \"course-watching-notification\",\n          course: cohort.course.toString(),\n        },\n        vars: {\n          course_name: cohort.courses.name,\n          cohort_page_url: `https://app.krakenedu.com/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohortId}`,\n          cohort_start_date: prettyDate(cohort.start_date),\n          course_description: cohort.courses.description,\n        },\n      };\n    }))\n  }\n\n\n  let newData = await prisma.course_cohorts.update({\n    where: {id: cohortId},\n    data: {\n      live: msg.data.live,\n      completed,\n      name: msg.data.name,\n      start_date: msg.data.start_date,\n      description: msg.data.description\n    }\n  })\n  if(!newData) return {status: 404, result: `No cohort with id ${cohortId} found`} as const\n  return {status: 200, result: newData} as const\n}\n\nexport const cohortDataQuery = async (id: number, userId?: string)=>{\n  let data = await prisma.course_cohorts.findUnique({\n    where: {id},\n    select: {\n      description: true,\n      name: true,\n      category_id: true,\n      start_date: true,\n      id: true,\n      live: true,\n      completed: true,\n      cohort_facilitators: {\n        select:{facilitator: true, people:{select:{display_name: true, username: true, bio: true, pronouns: true}}}\n      },\n      people: {\n        select: {display_name: true, username: true, bio: true, pronouns: true}\n      },\n      cohort_events: {\n        include: {\n          events: {\n            include: {\n              people_in_events: {select:{people:{select:{username: true, display_name: true, id: true}}}},\n            }\n          }\n        }\n      },\n      courses: {\n        select: {\n          name: true,\n          card_image: true,\n          cohort_max_size: true,\n          id: true,\n          type: true,\n          slug: true,\n          cost: true,\n          duration: true,\n          description: true,\n          category_id: true\n        }\n      },\n      people_in_cohorts: {\n        include: {\n          people: {\n            select: {\n              display_name: true,\n              pronouns: true,\n              username: true,\n              email: true,\n            }\n          }\n        },\n      }\n    },\n  })\n  if(!data) return\n\n  let enrolled = data.people_in_cohorts.find(x=>x.person === userId)\n  let isFacilitator = data.cohort_facilitators.find(f=>f.facilitator === userId)\n\n  let cohort_events = data.cohort_events\n    .filter(c=> c.everyone ||\n      isFacilitator ||\n      (enrolled  && c.events.people_in_events.find(p=>p.people.id === userId)))\n    .map(event => produce(event, (e)=>{if(!enrolled && !isFacilitator) e.events.location = ''}))\n  let people_in_cohorts = data.people_in_cohorts.map(person => produce(person, (p)=>{if(!isFacilitator)p.people.email = ''}))\n  return {...data, cohort_events, people_in_cohorts}\n}\n\nasync function getCohortData(req: Request) {\n  let cohortId = parseInt(req.query.cohortId as string)\n  if(Number.isNaN(cohortId)) return {status: 400, result: \"ERROR: Cohort id is not a number\"} as const\n  let user = getToken(req)\n\n  let data = await cohortDataQuery(cohortId, user?.id)\n  if(!data) return {status: 404, result: `Error: no cohort with id ${cohortId} found`} as const\n\n  return {status: 200, result: data} as const\n}\n"]},"metadata":{},"sourceType":"module"}