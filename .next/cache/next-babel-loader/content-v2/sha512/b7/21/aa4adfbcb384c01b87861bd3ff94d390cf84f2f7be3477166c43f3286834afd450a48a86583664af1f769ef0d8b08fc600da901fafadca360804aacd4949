{"ast":null,"code":"import Stripe from 'stripe';\nimport { getUsername, addMember, getTaggedPost } from 'src/discourse';\nimport { DISCOURSE_URL } from 'src/constants';\nimport { sendCohortEnrollmentEmail, sendEnrollNotificationEmaill, sendEventRSVPEmail } from 'emails';\nimport { prettyDate } from '../../src/utils';\nconst stripe = new Stripe(process.env.STRIPE_SECRET || '', {\n  apiVersion: '2020-08-27'\n});\nimport prisma from \"lib/prisma\";\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n};\nexport default (async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  if (!sig) return res.status(400).send(`Webhook Error: No signature!`);\n  let event;\n\n  try {\n    let body = await new Promise(resolve => {\n      let chunks = [];\n      req.on('data', chunk => {\n        chunks.push(chunk);\n      }).on('end', () => {\n        resolve(Buffer.concat(chunks).toString());\n      });\n    });\n    event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK);\n  } catch (err) {\n    return res.status(400).send(`Webhook Error: ${err.message}`);\n  } // Handle the checkout.session.completed event\n\n\n  if (event.type === 'checkout.session.completed') {\n    const {\n      metadata,\n      amount_total,\n      payment_intent,\n      customer\n    } = event.data.object;\n    if (!amount_total || !payment_intent || !customer || typeof payment_intent !== 'string' || typeof customer !== 'string') return {\n      status: 400,\n      result: \"ERROR: missing expected parameters, amount_total, payment_intent, or customer\"\n    };\n\n    switch (metadata.type) {\n      case 'cohort':\n        {\n          let cohortId = parseInt(metadata.cohortId);\n          let person = await prisma.people.findUnique({\n            where: {\n              id: metadata.userId\n            }\n          });\n          if (!person) return {\n            status: 400,\n            result: \"ERROR: cannot find user with id: \" + metadata.userId\n          };\n          let [cohort, discount] = await Promise.all([prisma.course_cohorts.findUnique({\n            where: {\n              id: cohortId\n            },\n            include: {\n              discourse_groups: true,\n              cohort_facilitators: {\n                select: {\n                  people: {\n                    select: {\n                      email: true\n                    }\n                  }\n                }\n              },\n              courses: {\n                select: {\n                  course_groupTodiscourse_groups: true,\n                  category_id: true,\n                  slug: true,\n                  name: true\n                }\n              },\n              people_in_cohorts: {\n                where: {\n                  person: person.id\n                }\n              }\n            }\n          }), metadata.discount ? prisma.course_discounts.findUnique({\n            where: {\n              code: metadata.discount\n            }\n          }) : null]);\n          if (!cohort) return {\n            status: 400,\n            result: \"ERROR: no cohort with id: \" + metadata.cohortId\n          };\n          if (cohort.people_in_cohorts.length > 0) return {\n            status: 200,\n            result: \"User is already enrolled\"\n          };\n          let username = await getUsername(metadata.userId);\n          if (!username) return res.status(400).send('ERROR: Cannot find user: ' + metadata.userId);\n          let gettingStarted = await getTaggedPost(cohort.category_id, 'getting-started');\n          await Promise.all([!person.stripe_customer_id ? prisma.people.update({\n            where: {\n              id: person.id\n            },\n            data: {\n              stripe_customer_id: customer\n            }\n          }) : null, discount ? prisma.course_discounts.update({\n            where: {\n              code: discount.code\n            },\n            data: {\n              redeems: {\n                increment: 1\n              }\n            }\n          }) : null, prisma.people_in_cohorts.create({\n            data: {\n              payment_intent,\n              amount_paid: amount_total / 100,\n              people: {\n                connect: {\n                  id: metadata.userId\n                }\n              },\n              course_cohorts: {\n                connect: {\n                  id: cohortId\n                }\n              },\n              course_discounts: discount ? {\n                connect: {\n                  code: discount.code\n                }\n              } : undefined\n            }\n          }), addMember(cohort.discourse_groups.id, username), addMember(cohort.courses.course_groupTodiscourse_groups.id, username), sendCohortEnrollmentEmail(person.email, {\n            name: person.display_name || person.username,\n            course_start_date: prettyDate(cohort.start_date),\n            course_name: cohort.courses.name,\n            cohort_page_url: `https://${window.location.origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n            cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n            get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`\n          }), Promise.all([cohort.cohort_facilitators.map(async f => person && cohort && sendEnrollNotificationEmaill(f.people.email, {\n            learner: person.display_name || person.username,\n            course: cohort.courses.name,\n            cohort_page_url: `https://${window.location.origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n            cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`\n          }))])]);\n          break;\n        }\n\n      case 'event':\n        {\n          let eventId = parseInt(metadata.eventId);\n          let [person, event] = await Promise.all([prisma.people.findUnique({\n            where: {\n              id: metadata.userId\n            }\n          }), prisma.standalone_events.findUnique({\n            where: {\n              event: eventId\n            },\n            select: {\n              events: true\n            }\n          })]);\n          if (!person) return {\n            status: 400,\n            result: \"ERROR: cannot find user with id: \" + metadata.userId\n          };\n          if (!event) return {\n            status: 400,\n            result: \"ERROR: cannot find event with id: \" + eventId\n          };\n          await Promise.all([sendEventRSVPEmail(person.email, {\n            name: person.display_name || person.username,\n            event_page_url: `https://${window.location.origin}/events/${event.events.id}`,\n            event_name: event.events.name\n          }), prisma.people_in_events.create({\n            data: {\n              events: {\n                connect: {\n                  id: event.events.id\n                }\n              },\n              people: {\n                connect: {\n                  id: person.id\n                }\n              }\n            }\n          })]);\n          break;\n        }\n    }\n  }\n\n  if (event.type === 'account.updated') {\n    const {\n      details_submitted,\n      payouts_enabled,\n      id\n    } = event.data.object;\n    if (details_submitted) await prisma.stripe_connected_accounts.update({\n      where: {\n        stripe_account: id\n      },\n      data: {\n        connected: true,\n        payouts_enabled\n      }\n    });\n  }\n\n  res.status(200).end();\n});","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/webhook.ts"],"names":["Stripe","getUsername","addMember","getTaggedPost","DISCOURSE_URL","sendCohortEnrollmentEmail","sendEnrollNotificationEmaill","sendEventRSVPEmail","prettyDate","stripe","process","env","STRIPE_SECRET","apiVersion","prisma","config","api","bodyParser","req","res","sig","headers","status","send","event","body","Promise","resolve","chunks","on","chunk","push","Buffer","concat","toString","webhooks","constructEvent","STRIPE_WEBHOOK","err","message","type","metadata","amount_total","payment_intent","customer","data","object","result","cohortId","parseInt","person","people","findUnique","where","id","userId","cohort","discount","all","course_cohorts","include","discourse_groups","cohort_facilitators","select","email","courses","course_groupTodiscourse_groups","category_id","slug","name","people_in_cohorts","course_discounts","code","length","username","gettingStarted","stripe_customer_id","update","redeems","increment","create","amount_paid","connect","undefined","display_name","course_start_date","start_date","course_name","cohort_page_url","window","location","origin","course","cohort_forum_url","get_started_topic_url","map","f","learner","eventId","standalone_events","events","event_page_url","event_name","people_in_events","details_submitted","payouts_enabled","stripe_connected_accounts","stripe_account","connected","end"],"mappings":"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","sourcesContent":["import { NextApiRequest, NextApiResponse} from 'next'\nimport Stripe from 'stripe'\nimport { getUsername, addMember, getTaggedPost, } from 'src/discourse'\nimport {DISCOURSE_URL} from 'src/constants'\nimport { sendCohortEnrollmentEmail, sendEnrollNotificationEmaill, sendEventRSVPEmail } from 'emails';\nimport { prettyDate } from '../../src/utils';\nimport { StripePaymentMetaData } from 'src/stripe';\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET || '', {apiVersion:'2020-08-27'});\n\nimport prisma from \"lib/prisma\";\n\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n};\n\nexport default async (req: NextApiRequest, res: NextApiResponse) => {\n  const sig = req.headers['stripe-signature'];\n  if(!sig) return res.status(400).send(`Webhook Error: No signature!`);\n  let event\n  try {\n    let body:string = await new Promise(resolve => {\n      let chunks: Uint8Array[] = []\n      req.on('data', (chunk) => {\n        chunks.push(chunk);\n      }).on('end', () => {\n        resolve(Buffer.concat(chunks).toString());\n      });\n    })\n    event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK as string);\n  } catch (err) {\n    return res.status(400).send(`Webhook Error: ${err.message}`);\n  }\n\n  // Handle the checkout.session.completed event\n  if (event.type === 'checkout.session.completed') {\n\n    const {metadata, amount_total, payment_intent, customer} = event.data.object as Stripe.Checkout.Session & {metadata: StripePaymentMetaData};\n    if(!amount_total ||!payment_intent || !customer ||\n      typeof payment_intent !== 'string' ||typeof customer !== 'string') return {status: 400, result: \"ERROR: missing expected parameters, amount_total, payment_intent, or customer\"}\n\n    switch(metadata.type) {\n        case 'cohort': {\n          let cohortId = parseInt(metadata.cohortId)\n          let person = await prisma.people.findUnique({where: {id: metadata.userId}})\n          if(!person) return {status: 400, result: \"ERROR: cannot find user with id: \" + metadata.userId} as const\n\n          let [cohort, discount] = await Promise.all([\n            prisma.course_cohorts.findUnique({\n              where: {id: cohortId},\n              include: {\n                discourse_groups: true,\n                cohort_facilitators: {select:{people:{select:{email:true}}}},\n                courses: {\n                  select: {\n                    course_groupTodiscourse_groups: true,\n                    category_id: true,\n                    slug: true,\n                    name: true\n                  }\n                },\n                people_in_cohorts: {\n                  where: {\n                    person: person.id\n                  }\n                }\n              }\n            }),\n            metadata.discount ? prisma.course_discounts.findUnique({where:{code:metadata.discount}}) : null\n          ])\n\n          if(!cohort) return {status: 400, result: \"ERROR: no cohort with id: \" + metadata.cohortId}\n          if(cohort.people_in_cohorts.length > 0) return {status:200, result: \"User is already enrolled\"}\n\n          let username = await getUsername(metadata.userId)\n\n          if(!username) return res.status(400).send('ERROR: Cannot find user: ' + metadata.userId)\n\n          let gettingStarted = await getTaggedPost(cohort.category_id, 'getting-started')\n\n          await Promise.all([\n            !person.stripe_customer_id ? prisma.people.update({where:{id: person.id}, data:{stripe_customer_id: customer}}) : null,\n            discount ? prisma.course_discounts.update({\n              where: {code: discount.code},\n              data: {\n                redeems: {\n                  increment: 1\n                }\n              }}) : null,\n            prisma.people_in_cohorts.create({data: {\n              payment_intent,\n              amount_paid: amount_total/100,\n              people: {connect: {id: metadata.userId}},\n              course_cohorts: {connect: {id: cohortId}},\n              course_discounts: discount ? {connect:{code: discount.code}} : undefined\n            }}),\n\n            addMember(cohort.discourse_groups.id, username),\n            addMember(cohort.courses.course_groupTodiscourse_groups.id, username),\n            sendCohortEnrollmentEmail(person.email, {\n              name: person.display_name || person.username,\n              course_start_date: prettyDate(cohort.start_date),\n              course_name: cohort.courses.name,\n              cohort_page_url: `https://${window.location.origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n              cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n              get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`\n            }),\n            Promise.all([cohort.cohort_facilitators.map(async (f) => person && cohort && sendEnrollNotificationEmaill(f.people.email, {\n              learner: person.display_name || person.username,\n              course: cohort.courses.name,\n              cohort_page_url: `https://${window.location.origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n              cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n            }))])\n          ])\n          break\n        }\n        case 'event': {\n          let eventId = parseInt(metadata.eventId)\n          let [person, event] = await Promise.all([\n            prisma.people.findUnique({where: {id: metadata.userId}}),\n            prisma.standalone_events.findUnique({where: {event: eventId}, select:{events: true}})\n          ])\n          if(!person) return {status: 400, result: \"ERROR: cannot find user with id: \" + metadata.userId} as const\n          if(!event) return {status:400, result: \"ERROR: cannot find event with id: \"+eventId}\n\n          await Promise.all([\n            sendEventRSVPEmail(person.email, {\n              name: person.display_name || person.username,\n              event_page_url: `https://${window.location.origin}/events/${event.events.id}`,\n              event_name: event.events.name\n            }),\n            prisma.people_in_events.create({data:{\n              events:{connect:{id: event.events.id}},\n              people:{connect:{id:person.id}}\n            }})\n          ])\n          break\n        }\n    }\n  }\n  if (event.type === 'account.updated') {\n    const {details_submitted, payouts_enabled, id} = event.data.object as {id: string, details_submitted: boolean, payouts_enabled: boolean, metadata: Stripe.Metadata} ;\n    if(details_submitted) await prisma.stripe_connected_accounts.update({\n      where:{stripe_account:id},\n      data:{\n        connected: true,\n        payouts_enabled\n      }\n    })\n\n  }\n\n  res.status(200).end()\n}\n"]},"metadata":{},"sourceType":"module"}