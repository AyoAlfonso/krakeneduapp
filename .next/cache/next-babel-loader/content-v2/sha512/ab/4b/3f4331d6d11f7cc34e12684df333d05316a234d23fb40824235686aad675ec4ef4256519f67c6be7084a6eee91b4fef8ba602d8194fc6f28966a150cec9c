{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { APIHandler } from \"src/apiHelpers\";\nimport prisma from \"lib/prisma\";\nimport { getToken } from \"src/token\";\nimport * as t from 'runtypes';\nimport produce from \"immer\";\nimport { sendEventUpdateNoAccountEmail } from \"emails\";\nimport { createEventInvite } from \"src/calendar\";\nexport default APIHandler({\n  POST: updateEvent,\n  DELETE: deleteEvent,\n  GET: getEvent\n});\nlet UpdateEventValidator = t.Intersect(t.Record({\n  data: t.Partial({\n    start_date: t.String,\n    end_date: t.String,\n    description: t.String,\n    location: t.String,\n    name: t.String\n  })\n}), t.Union(t.Record({\n  type: t.Literal('cohort'),\n  cohort: t.Number,\n  data: t.Partial({\n    people: t.Union(t.Undefined, t.Array(t.String))\n  })\n}), t.Record({\n  type: t.Literal('standalone'),\n  data: t.Partial({\n    cost: t.Number,\n    max_attendees: t.Number\n  })\n})));\nexport const eventDataQuery = async (id, userId) => {\n  let event = await prisma.events.findUnique({\n    where: {\n      id\n    },\n    include: {\n      people: {\n        select: {\n          display_name: true,\n          username: true,\n          bio: true,\n          id: true\n        }\n      },\n      people_in_events: {\n        include: {\n          people: {\n            select: {\n              display_name: true,\n              username: true,\n              pronouns: true,\n              email: true\n            }\n          }\n        }\n      },\n      no_account_rsvps: true,\n      cohort_events: true,\n      standalone_events: {\n        include: {\n          standalone_events_in_courses: true\n        }\n      }\n    }\n  });\n  if (!event) return;\n  let people_in_events = event.people_in_events.map(person => produce(person, p => {\n    if ((event === null || event === void 0 ? void 0 : event.created_by) !== userId) p.people.email = '';\n  }));\n  let no_accounts_rsvps = event.no_account_rsvps.map(person => (event === null || event === void 0 ? void 0 : event.created_by) !== userId ? _objectSpread(_objectSpread({}, person), {}, {\n    email: ''\n  }) : person);\n\n  if (userId != event.created_by && !event.people_in_events.find(p => p.person === userId)) {\n    return _objectSpread(_objectSpread({}, event), {}, {\n      people_in_events,\n      location: ''\n    });\n  }\n\n  return _objectSpread(_objectSpread({}, event), {}, {\n    people_in_events,\n    no_accounts_rsvps\n  });\n};\n\nasync function getEvent(req) {\n  let user = getToken(req);\n  let eventId = parseInt(req.query.id);\n  if (Number.isNaN(eventId)) return {\n    status: 400,\n    result: \"ERROR: event id is not a number\"\n  };\n  let event = await eventDataQuery(eventId, user === null || user === void 0 ? void 0 : user.id);\n  if (!event) return {\n    status: 404,\n    result: 'ERROR: no event with id found'\n  };\n  return {\n    status: 200,\n    result: event\n  };\n}\n\nasync function updateEvent(req) {\n  let eventId = parseInt(req.query.id);\n  if (Number.isNaN(eventId)) return {\n    status: 400,\n    result: \"ERROR: event id is not a number\"\n  };\n  let msg;\n\n  try {\n    msg = UpdateEventValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"ERROR: no user logged in\"\n  };\n  let event = await prisma.events.findUnique({\n    where: {\n      id: eventId\n    },\n    select: {\n      id: true,\n      created_by: true,\n      no_account_rsvps: true,\n      name: true\n    }\n  });\n  if (!event) return {\n    status: 404,\n    result: 'ERROR: no event found'\n  };\n\n  switch (msg.type) {\n    case 'cohort':\n      {\n        var _msg$data$people;\n\n        let cohort = await prisma.course_cohorts.findUnique({\n          where: {\n            id: msg.cohort\n          },\n          select: {\n            cohort_facilitators: true\n          }\n        });\n        if (!cohort) return {\n          status: 404,\n          result: `ERROR: no cohort with id ${msg.cohort} found`\n        };\n        if (!cohort.cohort_facilitators.find(f => user && f.facilitator === user.id) && event.created_by !== user.id) return {\n          status: 401,\n          result: \"ERROR: user is not creator of event or a facilitator of the cohort\"\n        };\n        let newEvent = await prisma.cohort_events.update({\n          where: {\n            cohort_event: {\n              cohort: msg.cohort,\n              event: eventId\n            }\n          },\n          include: {\n            events: {\n              include: {\n                people_in_events: {\n                  select: {\n                    people: {\n                      select: {\n                        username: true,\n                        display_name: true,\n                        id: true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          data: {\n            everyone: msg.data.people ? msg.data.people.length === 0 : undefined,\n            events: {\n              update: {\n                location: msg.data.location,\n                start_date: msg.data.start_date,\n                end_date: msg.data.end_date,\n                description: msg.data.description,\n                name: msg.data.name,\n                people_in_events: {\n                  deleteMany: {\n                    event: eventId\n                  },\n                  create: (_msg$data$people = msg.data.people) === null || _msg$data$people === void 0 ? void 0 : _msg$data$people.map(p => {\n                    return {\n                      people: {\n                        connect: {\n                          username: p\n                        }\n                      }\n                    };\n                  })\n                }\n              }\n            }\n          }\n        });\n        return {\n          status: 200,\n          result: {\n            type: 'cohort',\n            data: newEvent\n          }\n        };\n      }\n\n    case 'standalone':\n      {\n        if (event.created_by !== user.id) return {\n          status: 401,\n          result: \"ERROR: user is not a facilitator of the cohort\"\n        };\n        let newEvent = await prisma.standalone_events.update({\n          where: {\n            event: eventId\n          },\n          include: {\n            standalone_events_in_courses: true,\n            events: {\n              include: {\n                people: true,\n                no_account_rsvps: true,\n                people_in_events: {\n                  where: {\n                    person: user.id\n                  },\n                  include: {\n                    people: {\n                      select: {\n                        display_name: true,\n                        username: true,\n                        pronouns: true,\n                        email: true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          data: {\n            cost: msg.data.cost,\n            max_attendees: msg.data.max_attendees,\n            events: {\n              update: {\n                start_date: msg.data.start_date,\n                end_date: msg.data.end_date,\n                description: msg.data.description,\n                name: msg.data.name\n              }\n            }\n          }\n        });\n\n        if (msg.data.start_date || msg.data.end_date || msg.data.location || msg.data.location || msg.data.name) {\n          let Content = Buffer.from(createEventInvite({\n            id: newEvent.events.id,\n            description: newEvent.events.description,\n            start_date: newEvent.events.start_date,\n            end_date: newEvent.events.end_date,\n            summary: newEvent.events.name,\n            location: newEvent.events.location\n          }).toString()).toString('base64');\n          await sendEventUpdateNoAccountEmail(event.no_account_rsvps.map(rsvp => {\n            return {\n              email: rsvp.email,\n              vars: {\n                name: rsvp.name,\n                event_name: (event === null || event === void 0 ? void 0 : event.name) || \"\",\n                event_page_url: `https://app.krakenedu.com/events/${event === null || event === void 0 ? void 0 : event.id}`\n              },\n              data: {\n                Attachments: [{\n                  Name: \"event.ics\",\n                  ContentType: \"text/calender\",\n                  ContentID: null,\n                  Content\n                }]\n              }\n            };\n          }));\n        }\n\n        return {\n          status: 200,\n          result: {\n            type: 'standalone',\n            data: newEvent\n          }\n        };\n      }\n  }\n}\n\nasync function deleteEvent(req) {\n  var _event$cohort_events$;\n\n  let eventId = parseInt(req.query.id);\n  if (Number.isNaN(eventId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"ERROR: no user logged in\"\n  };\n  let event = await prisma.events.findUnique({\n    where: {\n      id: eventId\n    },\n    select: {\n      created_by: true,\n      cohort_events: {\n        select: {\n          course_cohorts: {\n            select: {\n              cohort_facilitators: true,\n              people_in_cohorts: {\n                select: {\n                  people: {\n                    select: {\n                      username: true\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  if (!event) return {\n    status: 404,\n    result: `ERROR: no event with id ${eventId} found`\n  };\n  if (!((_event$cohort_events$ = event.cohort_events[0]) !== null && _event$cohort_events$ !== void 0 && _event$cohort_events$.course_cohorts.cohort_facilitators.find(f => user && f.facilitator === user.id)) && user.id !== event.created_by) return {\n    status: 401,\n    result: \"ERROR: user is not a facilitator of the cohort this event is in\"\n  };\n  await prisma.cohort_events.deleteMany({\n    where: {\n      event: eventId\n    }\n  }), await prisma.people_in_events.deleteMany({\n    where: {\n      event: eventId\n    }\n  });\n  await prisma.events.delete({\n    where: {\n      id: eventId\n    }\n  });\n  return {\n    status: 200,\n    result: true\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/events/[id]/index.ts"],"names":["APIHandler","prisma","getToken","t","produce","sendEventUpdateNoAccountEmail","createEventInvite","POST","updateEvent","DELETE","deleteEvent","GET","getEvent","UpdateEventValidator","Intersect","Record","data","Partial","start_date","String","end_date","description","location","name","Union","type","Literal","cohort","Number","people","Undefined","Array","cost","max_attendees","eventDataQuery","id","userId","event","events","findUnique","where","include","select","display_name","username","bio","people_in_events","pronouns","email","no_account_rsvps","cohort_events","standalone_events","standalone_events_in_courses","map","person","p","created_by","no_accounts_rsvps","find","req","user","eventId","parseInt","query","isNaN","status","result","msg","check","body","e","toString","course_cohorts","cohort_facilitators","f","facilitator","newEvent","update","cohort_event","everyone","length","undefined","deleteMany","create","connect","Content","Buffer","from","summary","rsvp","vars","event_name","event_page_url","Attachments","Name","ContentType","ContentID","people_in_cohorts","delete"],"mappings":"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","sourcesContent":["import { APIHandler, Request, ResultType } from \"src/apiHelpers\";\nimport prisma from \"lib/prisma\";\nimport { getToken } from \"src/token\";\nimport * as t from 'runtypes'\nimport produce from \"immer\";\nimport { sendEventUpdateNoAccountEmail } from \"emails\";\nimport { createEventInvite } from \"src/calendar\";\n\n\nexport default APIHandler({\n  POST: updateEvent,\n  DELETE: deleteEvent,\n  GET: getEvent\n})\nexport type UpdateEventMsg = t.Static<typeof UpdateEventValidator>\nexport type UpdateEventResult = ResultType<typeof updateEvent>\nexport type DeleteEventResult = ResultType<typeof deleteEvent>\nexport type GETEventResult = ResultType<typeof getEvent>\n\nlet UpdateEventValidator = t.Intersect(\n  t.Record({data: t.Partial({\n    start_date: t.String,\n    end_date: t.String,\n    description: t.String,\n    location: t.String,\n    name: t.String,\n  })}),\n  t.Union(\n    t.Record({\n      type: t.Literal('cohort'),\n      cohort: t.Number,\n      data: t.Partial({\n        people: t.Union(t.Undefined, t.Array(t.String))\n      })\n    }), t.Record({\n      type: t.Literal('standalone'),\n      data: t.Partial({\n        cost: t.Number,\n        max_attendees: t.Number\n      })\n    })\n  ))\n\nexport const eventDataQuery = async (id: number, userId?:string)=>{\n  let event = await prisma.events.findUnique({\n    where: {id},\n    include:{\n      people: {select:{display_name: true, username: true, bio: true, id: true}},\n      people_in_events: {include:{people:{select:{display_name: true, username: true, pronouns: true, email: true}}}},\n      no_account_rsvps: true,\n      cohort_events: true,\n      standalone_events: {\n        include: {\n          standalone_events_in_courses: true\n        }\n      }\n    }\n  })\n  if(!event) return\n  let people_in_events = event.people_in_events.map(person=>produce(person, p=>{if(event?.created_by!==userId)p.people.email=''}))\n  let no_accounts_rsvps = event.no_account_rsvps.map(person=>event?.created_by!==userId ? {...person, email:''} : person)\n\n  if(userId != event.created_by && !event.people_in_events.find(p=>p.person===userId)) {\n    return {...event, people_in_events, location: ''}\n  }\n  return {...event, people_in_events, no_accounts_rsvps}\n}\n\nasync function getEvent(req:Request) {\n  let user = getToken(req)\n  let eventId = parseInt(req.query.id as string)\n  if(Number.isNaN(eventId)) return {status: 400, result: \"ERROR: event id is not a number\"} as const\n  let event = await eventDataQuery(eventId, user?.id)\n  if(!event) return {status:404, result: 'ERROR: no event with id found'} as const\n  return {status:200, result: event} as const\n}\n\nasync function updateEvent(req:Request) {\n  let eventId = parseInt(req.query.id as string)\n  if(Number.isNaN(eventId)) return {status: 400, result: \"ERROR: event id is not a number\"} as const\n  let msg\n  try {msg = UpdateEventValidator.check(req.body)}\n  catch(e) {\n    return {status:400, result:e.toString()} as const\n  }\n\n  let user = getToken(req)\n  if(!user) return {status: 401 , result: \"ERROR: no user logged in\"} as const\n\n  let event = await prisma.events.findUnique({where:{id: eventId}, select:{id: true, created_by: true, no_account_rsvps: true, name: true}})\n  if(!event) return {status:404, result: 'ERROR: no event found'} as const\n\n  switch(msg.type){\n      case 'cohort': {\n        let cohort = await prisma.course_cohorts.findUnique({where: {id: msg.cohort}, select:{cohort_facilitators: true}})\n        if(!cohort) return {status: 404, result: `ERROR: no cohort with id ${msg.cohort} found`} as const\n\n        if(!cohort.cohort_facilitators.find(f=>user&&f.facilitator===user.id) && event.created_by!==user.id) return {status: 401, result: \"ERROR: user is not creator of event or a facilitator of the cohort\"} as const\n\n        let newEvent = await prisma.cohort_events.update({\n          where:{cohort_event:{cohort: msg.cohort, event: eventId}},\n          include: {\n            events: {\n              include: {\n                people_in_events: {select:{people:{select:{username: true, display_name: true, id: true}}}},\n              }\n            }\n          },\n          data:{\n            everyone: msg.data.people ? msg.data.people.length === 0 : undefined,\n            events:{\n              update:{\n                location: msg.data.location,\n                start_date: msg.data.start_date,\n                end_date: msg.data.end_date,\n                description: msg.data.description,\n                name: msg.data.name,\n                people_in_events: {\n                  deleteMany:{event: eventId},\n                  create: msg.data.people?.map(p=>{\n                    return {\n                      people:{connect:{username: p}}\n                    }\n                  })\n                }\n              }\n            }\n          }\n        })\n        return {status: 200, result: {type: 'cohort', data: newEvent}} as const\n      }\n      case 'standalone': {\n        if(event.created_by !== user.id) return {status: 401, result: \"ERROR: user is not a facilitator of the cohort\"} as const\n        let newEvent = await prisma.standalone_events.update({\n          where:{event:eventId},\n          include: {\n            standalone_events_in_courses: true,\n            events: {include: {\n              people: true,\n              no_account_rsvps: true,\n              people_in_events: {where: {person: user.id}, include:{people:{select:{display_name: true, username: true, pronouns: true, email: true}}}}\n            }},\n          },\n          data: {\n            cost: msg.data.cost,\n            max_attendees: msg.data.max_attendees,\n            events:{\n              update:{\n                start_date: msg.data.start_date,\n                end_date: msg.data.end_date,\n                description: msg.data.description,\n                name: msg.data.name,\n              }\n            }\n          }\n        })\n\n        if(msg.data.start_date || msg.data.end_date || msg.data.location || msg.data.location || msg.data.name) {\n          let Content = Buffer.from(createEventInvite({\n            id: newEvent.events.id,\n            description: newEvent.events.description,\n            start_date: newEvent.events.start_date,\n            end_date: newEvent.events.end_date,\n            summary: newEvent.events.name,\n            location: newEvent.events.location\n          }).toString()).toString('base64')\n\n          await sendEventUpdateNoAccountEmail(event.no_account_rsvps.map(rsvp=> {\n            return {\n              email: rsvp.email,\n              vars: {\n                name: rsvp.name,\n                event_name: event?.name || \"\",\n                event_page_url: `https://app.krakenedu.com/events/${event?.id}`,\n              },\n              data: {\n                Attachments: [\n                  {\n                    Name: \"event.ics\",\n                    ContentType: \"text/calender\",\n                    ContentID: null,\n                    Content,\n                  },\n                ],\n              },\n            };\n          }))\n        }\n\n        return {status: 200, result: {type: 'standalone', data: newEvent}} as const\n      }\n  }\n\n}\n\nasync function deleteEvent(req:Request) {\n  let eventId = parseInt(req.query.id as string)\n  if(Number.isNaN(eventId)) return {status: 400, result: \"ERROR: Cohort id is not a number\"} as const\n  let user = getToken(req)\n  if(!user) return {status: 401 , result: \"ERROR: no user logged in\"} as const\n\n  let event = await prisma.events.findUnique({\n    where: {id: eventId},\n    select: {\n      created_by: true,\n      cohort_events: {\n        select:{\n          course_cohorts: {\n            select:{cohort_facilitators: true, people_in_cohorts:{select:{people:{select: {username: true}}}}}\n          }\n        }\n      }\n    }\n  })\n\n  if(!event) return {status: 404, result: `ERROR: no event with id ${eventId} found`} as const\n\n  if(!event.cohort_events[0]?.course_cohorts.cohort_facilitators.find(f=>user&&f.facilitator===user.id) && user.id !== event.created_by) return {status: 401, result: \"ERROR: user is not a facilitator of the cohort this event is in\"} as const\n\n  await prisma.cohort_events.deleteMany({where: {event: eventId}}),\n  await prisma.people_in_events.deleteMany({where:{event: eventId}})\n  await prisma.events.delete({\n    where: {id: eventId}\n  })\n  return {status: 200, result: true}\n}\n"]},"metadata":{},"sourceType":"module"}