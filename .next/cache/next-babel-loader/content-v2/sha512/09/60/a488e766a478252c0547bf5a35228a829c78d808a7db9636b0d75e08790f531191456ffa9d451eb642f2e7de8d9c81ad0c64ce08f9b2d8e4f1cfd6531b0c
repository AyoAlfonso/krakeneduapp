{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { APIHandler } from 'src/apiHelpers';\nimport { getToken } from 'src/token';\nimport { createGroup, createCategory, updateTopic, createTopic, updateCategory } from 'src/discourse';\nimport prisma from \"lib/prisma\";\nexport default APIHandler(handler);\n\nasync function handler(req) {\n  var _facilitators$3;\n\n  let msg = req.body;\n  if (!msg.courseId || !msg.start || !msg.facilitators) return {\n    status: 400,\n    result: \"Error: invalid request, missing parameters\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 403,\n    result: \"Error: no user logged in\"\n  };\n  let isUserMaintainer = await prisma.course_maintainers.findUnique({\n    where: {\n      course_maintainer: {\n        course: msg.courseId,\n        maintainer: user.id\n      }\n    }\n  });\n\n  if (!isUserMaintainer) {\n    return {\n      status: 403,\n      result: \"ERROR: user is not maintainer of course\"\n    };\n  }\n\n  let [course, facilitators] = await Promise.all([prisma.courses.findUnique({\n    where: {\n      id: msg.courseId\n    },\n    select: {\n      description: true,\n      slug: true,\n      id: true,\n      type: true,\n      category_id: true,\n      name: true,\n      status: true,\n      course_templates: true,\n      course_groupTodiscourse_groups: true,\n      maintainer_groupTodiscourse_groups: true,\n      course_cohorts: {\n        select: {\n          discourse_groups: true\n        }\n      }\n    }\n  }), Promise.all(msg.facilitators.map(f => prisma.people.findUnique({\n    where: {\n      id: f\n    },\n    select: {\n      username: true,\n      id: true\n    }\n  })))]);\n  if (!course) return {\n    status: 400,\n    result: \"ERROR: no course found with that id\"\n  };\n\n  for (let f in facilitators) {\n    if (!facilitators[f]) return {\n      status: 404,\n      result: \"ERROR: no user with username \" + msg.facilitators[f]\n    };\n  }\n\n  let groupName = course.slug + '-' + course.course_cohorts.length;\n  let group = await createGroup({\n    name: groupName,\n    visibility_level: 2,\n    owner_usernames: facilitators.map(f => f === null || f === void 0 ? void 0 : f.username).join(','),\n    mentionable_level: 3,\n    messageable_level: 3\n  });\n  if (!group) return {\n    status: 500,\n    result: \"ERROR: unable to create group\"\n  };\n\n  let courseCategoryPermissions = _objectSpread(_objectSpread({}, course.course_cohorts.reduce((acc, cohort) => {\n    acc[cohort.discourse_groups.name] = 1;\n    return acc;\n  }, {})), {}, {\n    [groupName]: 1,\n    [course.maintainer_groupTodiscourse_groups.name]: 1,\n    [course.course_groupTodiscourse_groups.name]: 1\n  });\n\n  await updateCategory(course.category_id, {\n    name: course.name,\n    permissions: courseCategoryPermissions\n  });\n  let category = await createCategory(groupName, {\n    permissions: {\n      [groupName]: 1\n    },\n    parent_category_id: course.category_id\n  });\n  if (!category) return {\n    status: 500,\n    result: \"ERROR: Could not create cohort category\"\n  };\n  await Promise.all(course.course_templates.map(async template => {\n    if (!category) return;\n\n    if (template.type === 'prepopulated') {\n      if (template.name === \"Getting Started\") {\n        var _facilitators$;\n\n        return updateTopic(category.topic_url, {\n          category_id: category.id,\n          title: \" Getting Started\",\n          raw: template.content,\n          tags: ['getting-started']\n        }, (_facilitators$ = facilitators[0]) === null || _facilitators$ === void 0 ? void 0 : _facilitators$.username);\n      } else {\n        var _facilitators$2;\n\n        return createTopic({\n          title: template.title,\n          category: category.id,\n          raw: template.content,\n          tags: template.name === \"Getting Started\" ? ['getting-started'] : undefined\n        }, (_facilitators$2 = facilitators[0]) === null || _facilitators$2 === void 0 ? void 0 : _facilitators$2.username);\n      }\n    }\n  }));\n  let cohort = await prisma.course_cohorts.create({\n    include: {\n      people: {\n        select: {\n          display_name: true,\n          username: true\n        }\n      },\n      cohort_facilitators: {\n        select: {\n          facilitator: true,\n          people: {\n            select: {\n              display_name: true,\n              username: true\n            }\n          }\n        }\n      }\n    },\n    data: {\n      name: course.course_cohorts.length.toString(),\n      category_id: category.id,\n      description: course.description,\n      discourse_groups: {\n        create: {\n          id: group.basic_group.id,\n          name: groupName\n        }\n      },\n      people: {\n        connect: {\n          id: (_facilitators$3 = facilitators[0]) === null || _facilitators$3 === void 0 ? void 0 : _facilitators$3.id\n        }\n      },\n      // REMOVE WHEN WE DROP THIS COLUMN\n      start_date: msg.start,\n      courses: {\n        connect: {\n          id: course.id\n        }\n      },\n      cohort_facilitators: {\n        create: facilitators.map(f => {\n          return {\n            facilitator: (f === null || f === void 0 ? void 0 : f.id) || ''\n          };\n        })\n      }\n    }\n  });\n  return {\n    status: 200,\n    result: cohort\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/cohorts/index.ts"],"names":["APIHandler","getToken","createGroup","createCategory","updateTopic","createTopic","updateCategory","prisma","handler","req","msg","body","courseId","start","facilitators","status","result","user","isUserMaintainer","course_maintainers","findUnique","where","course_maintainer","course","maintainer","id","Promise","all","courses","select","description","slug","type","category_id","name","course_templates","course_groupTodiscourse_groups","maintainer_groupTodiscourse_groups","course_cohorts","discourse_groups","map","f","people","username","groupName","length","group","visibility_level","owner_usernames","join","mentionable_level","messageable_level","courseCategoryPermissions","reduce","acc","cohort","permissions","category","parent_category_id","template","topic_url","title","raw","content","tags","undefined","create","include","display_name","cohort_facilitators","facilitator","data","toString","basic_group","connect","start_date"],"mappings":"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","sourcesContent":["import {APIHandler, Request, ResultType} from 'src/apiHelpers'\nimport { getToken } from 'src/token'\nimport { createGroup, createCategory, updateTopic, createTopic, updateCategory } from 'src/discourse'\nimport prisma from \"lib/prisma\";\n\nexport type CreateCohortMsg = {\n  courseId: number,\n  start: string,\n  facilitators: string[],\n}\nexport type CreateCohortResponse = ResultType<typeof handler>\n\nexport default APIHandler(handler)\n\nasync function handler (req: Request) {\n  let msg = req.body as Partial<CreateCohortMsg>\n  if(!msg.courseId || !msg.start ||\n    !msg.facilitators) return {status: 400, result: \"Error: invalid request, missing parameters\"} as const\n\n  let user = getToken(req)\n  if(!user) return {status: 403, result: \"Error: no user logged in\"} as const\n  let isUserMaintainer = await prisma.course_maintainers.findUnique({where: {\n    course_maintainer: {\n      course: msg.courseId,\n      maintainer: user.id\n    }\n  }})\n  if(!isUserMaintainer) {\n    return {status: 403, result: \"ERROR: user is not maintainer of course\"} as const\n  }\n\n  let [course, facilitators] = await Promise.all([\n    prisma.courses.findUnique({\n      where: {id: msg.courseId},\n      select: {\n        description: true,\n        slug: true,\n        id: true,\n        type: true,\n        category_id: true,\n        name: true,\n        status: true,\n        course_templates: true,\n        course_groupTodiscourse_groups: true,\n        maintainer_groupTodiscourse_groups: true,\n        course_cohorts: {\n          select: {discourse_groups: true}\n        }\n      },\n    }),\n    Promise.all(msg.facilitators.map(f=>prisma.people.findUnique({where:{id: f}, select:{username:true, id: true}})))\n  ])\n  if(!course) return {status: 400, result: \"ERROR: no course found with that id\"} as const\n  for(let f in facilitators){\n    if(!facilitators[f]) return {status:404, result: \"ERROR: no user with username \"+msg.facilitators[f]} as const\n  }\n\n  let groupName = course.slug + '-' + course.course_cohorts.length\n  let group = await createGroup({\n    name: groupName,\n    visibility_level:2,\n    owner_usernames: facilitators.map(f=>f?.username).join(','),\n    mentionable_level: 3,\n    messageable_level: 3\n  })\n  if(!group) return {status:500, result: \"ERROR: unable to create group\"} as const\n\n  let courseCategoryPermissions = {\n    // Make sure to keep any existing cohorts as well\n    ...course.course_cohorts.reduce((acc, cohort) => {\n      acc[cohort.discourse_groups.name] = 1\n      return acc\n    }, {} as {[i:string]:number}),\n    [groupName]: 1,\n    [course.maintainer_groupTodiscourse_groups.name]: 1,\n    [course.course_groupTodiscourse_groups.name]: 1\n  }\n\n  await updateCategory(course.category_id, {name: course.name, permissions: courseCategoryPermissions})\n  let category = await createCategory(groupName, {permissions: {[groupName]:1}, parent_category_id: course.category_id})\n  if(!category) return {status: 500, result: \"ERROR: Could not create cohort category\"} as const\n\n  await Promise.all(course.course_templates.map( async template => {\n    if(!category) return\n    if(template.type === 'prepopulated') {\n      if(template.name === \"Getting Started\") {\n        return updateTopic(category.topic_url, {\n          category_id: category.id,\n          title: \" Getting Started\",\n          raw: template.content,\n          tags: ['getting-started']\n        }, facilitators[0]?.username)\n      }\n      else {\n        return createTopic({\n          title: template.title,\n          category: category.id,\n          raw: template.content,\n          tags: template.name === \"Getting Started\" ? ['getting-started'] : undefined,\n        }, facilitators[0]?.username)\n      }\n    }\n  }))\n\n  let cohort = await prisma.course_cohorts.create({\n    include: {\n      people: {select: {display_name: true, username: true}},\n      cohort_facilitators: {select:{facilitator: true, people: {select:{display_name: true, username: true}}}},\n    },\n    data: {\n      name: course.course_cohorts.length.toString(),\n      category_id: category.id,\n      description: course.description,\n      discourse_groups:{\n        create:{\n          id: group.basic_group.id,\n          name: groupName\n        }\n      },\n      people: {connect:{id:facilitators[0]?.id as string}}, // REMOVE WHEN WE DROP THIS COLUMN\n      start_date: msg.start,\n      courses: {\n        connect: {\n          id: course.id\n        }\n      },\n      cohort_facilitators: {\n        create: facilitators.map(f=>{return {facilitator: f?.id || ''}})\n\n      }\n    }\n  })\n\n  return {status: 200, result: cohort} as const\n}\n"]},"metadata":{},"sourceType":"module"}