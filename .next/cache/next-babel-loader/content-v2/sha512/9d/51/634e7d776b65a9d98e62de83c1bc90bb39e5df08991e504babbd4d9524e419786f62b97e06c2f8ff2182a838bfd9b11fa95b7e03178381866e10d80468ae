{"ast":null,"code":"import * as rt from \"runtypes\";\nimport { APIHandler } from \"src/apiHelpers\";\nimport { stripe } from \"src/stripe\";\nimport { sendCohortEnrollmentEmail, sendEnrollNotificationEmaill, sendUnenrollEmail } from \"emails\";\nimport { getToken } from \"src/token\";\nimport { addMember, getTaggedPost } from \"src/discourse\";\nimport { DISCOURSE_URL } from \"src/constants\";\nimport { prettyDate } from \"src/utils\";\nimport prisma from \"lib/prisma\";\nexport default APIHandler({\n  POST: enroll,\n  DELETE: unenroll\n});\nlet EnrollMsgValidator = rt.Record({\n  discount: rt.Union(rt.Undefined, rt.String),\n  paystack: rt.Union(rt.Undefined, rt.Boolean)\n});\nlet UnEnrollMsgValidator = rt.Record({\n  person: rt.String\n});\n\nasync function enroll(req) {\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"Error: no user logged in\"\n  };\n  let msg;\n\n  try {\n    msg = EnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let {\n    paystack\n  } = msg;\n  let [cohort, person, discount] = await Promise.all([prisma.course_cohorts.findUnique({\n    where: {\n      id: cohortId\n    },\n    include: {\n      discourse_groups: true,\n      cohort_facilitators: {\n        select: {\n          people: {\n            select: {\n              email: true\n            }\n          }\n        }\n      },\n      courses: {\n        select: {\n          course_groupTodiscourse_groups: true,\n          invite_only: true,\n          category_id: true,\n          cost: true,\n          slug: true,\n          name: true,\n          course_invites: {\n            where: {\n              email: user.email\n            }\n          }\n        }\n      }\n    }\n  }), prisma.people.findUnique({\n    where: {\n      id: user.id\n    }\n  }), msg.discount ? prisma.course_discounts.findUnique({\n    where: {\n      code: msg.discount\n    }\n  }) : null]);\n  if (!cohort || cohort.courses.cost === undefined) return {\n    status: 400,\n    result: \"Error: no cohort with id \" + cohortId + \" found\"\n  };\n  if (msg.discount && (!discount || discount.deleted)) return {\n    status: 404,\n    result: {\n      discount: msg.discount\n    }\n  };\n  if (discount && discount.max_redeems !== 0 && discount.max_redeems <= discount.redeems) return {\n    status: 403,\n    result: {\n      message: \"ERROR: Discount code has no uses left\",\n      discount: msg.discount\n    }\n  };\n\n  if (cohort.courses.invite_only && cohort.courses.course_invites.length === 0) {\n    return {\n      status: 401,\n      result: \"ERROR: Course is invite_only and user is not invited\"\n    };\n  }\n\n  let origin = new URL(req.headers.referer || \"\").origin;\n  let price = cohort.courses.cost;\n\n  if (discount) {\n    if (discount.type === \"absolute\") price = price - discount.amount;else price = price - Math.floor(discount.amount / 100 * price);\n  }\n\n  if (price === 0) {\n    let gettingStarted = await getTaggedPost(cohort.category_id, \"getting-started\");\n    await Promise.all([discount ? prisma.course_discounts.update({\n      where: {\n        code: discount.code\n      },\n      data: {\n        redeems: {\n          increment: 1\n        }\n      }\n    }) : null, prisma.people_in_cohorts.create({\n      data: {\n        amount_paid: 0,\n        people: {\n          connect: {\n            id: user.id\n          }\n        },\n        course_cohorts: {\n          connect: {\n            id: cohortId\n          }\n        },\n        course_discounts: discount ? {\n          connect: {\n            code: discount.code\n          }\n        } : undefined\n      }\n    }), addMember(cohort.discourse_groups.id, user.username), addMember(cohort.courses.course_groupTodiscourse_groups.id, user.username), sendCohortEnrollmentEmail(user.email, {\n      name: user.display_name || user.username,\n      course_start_date: prettyDate(cohort.start_date),\n      course_name: cohort.courses.name,\n      cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n      cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n      get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`\n    }), Promise.all([cohort.cohort_facilitators.map(async (f) => person && cohort && sendEnrollNotificationEmaill(f.people.email, {\n      learner: person.display_name || person.username,\n      course: cohort.courses.name,\n      cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n      cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`\n    }))])]);\n    return {\n      status: 200,\n      result: {\n        zeroCost: true\n      }\n    };\n  } //TO DO: get the price of naira per hour and save in separate mongo db\n\n\n  let metadata = {\n    type: \"cohort\",\n    cohortId: cohort.id.toString(),\n    userId: user.id,\n    discount: (discount === null || discount === void 0 ? void 0 : discount.code) || null\n  };\n\n  if (paystack) {\n    return {\n      status: 200,\n      result: {\n        amount: price * 400 * 100,\n        email: user.email,\n        metadata\n      }\n    };\n  }\n\n  const session = await stripe.checkout.sessions.create({\n    payment_method_types: [\"card\"],\n    customer: (person === null || person === void 0 ? void 0 : person.stripe_customer_id) || undefined,\n    customer_email: person !== null && person !== void 0 && person.stripe_customer_id ? undefined : user.email,\n    payment_intent_data: {\n      transfer_group: cohort.id.toString()\n    },\n    line_items: [{\n      name: cohort.courses.name + (discount ? `, ${(discount === null || discount === void 0 ? void 0 : discount.type) === \"absolute\" ? \"$\" + (discount === null || discount === void 0 ? void 0 : discount.amount) : (discount === null || discount === void 0 ? void 0 : discount.amount) + \"%\"} Off` : \"\"),\n      amount: price * 100,\n      currency: \"usd\",\n      quantity: 1 //TO DO: Add discount\n\n    }],\n    cancel_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n    success_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}?welcome`,\n    metadata\n  });\n  return {\n    status: 200,\n    result: {\n      sessionId: session.id\n    }\n  };\n}\n\nasync function unenroll(req) {\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"Error: no user logged in\"\n  };\n  let msg;\n\n  try {\n    msg = UnEnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let [cohort] = await Promise.all([prisma.course_cohorts.findUnique({\n    where: {\n      id: cohortId\n    },\n    select: {\n      cohort_facilitators: true,\n      courses: {\n        select: {\n          name: true\n        }\n      },\n      discourse_groups: true,\n      people: {\n        select: {\n          email: true\n        }\n      },\n      people_in_cohorts: {\n        select: {\n          person: true,\n          payment_intent: true,\n          amount_paid: true,\n          people: {\n            select: {\n              display_name: true,\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    }\n  })]);\n  if (!cohort) return {\n    status: 404,\n    result: \"ERROR: no cohort found with id: \" + cohortId\n  };\n  if (!cohort.cohort_facilitators.find(f => user && f.facilitator === user.id)) return {\n    status: 401,\n    result: `ERROR: User is not facilitator of cohort`\n  };\n  let person = cohort.people_in_cohorts.find(p => p.person === msg.person);\n  if (!person) return {\n    status: 404,\n    result: \"ERROR: User is not in cohort\"\n  };\n  if (!person.payment_intent && person.amount_paid !== 0) return {\n    status: 500,\n    result: \"ERROR: Amount paid is greater than zero but there is not payment information\"\n  }; // TO DO check what payment_intent is\n\n  await Promise.all([sendUnenrollEmail(person.people.email, {\n    name: person.people.display_name || person.people.username,\n    course_name: cohort.courses.name,\n    paid: person.amount_paid > 0 ? \"true\" : \"\"\n  }), prisma.people_in_cohorts.delete({\n    where: {\n      person_cohort: {\n        person: msg.person,\n        cohort: cohortId\n      }\n    }\n  }), !person.payment_intent ? undefined : prisma.refunds.create({\n    data: {\n      payment_intent: person.payment_intent,\n      amount: person.amount_paid,\n      cohort_refunds: {\n        create: {\n          course_cohorts: {\n            connect: {\n              id: cohortId\n            }\n          },\n          people: {\n            connect: {\n              id: person.person\n            }\n          }\n        }\n      }\n    }\n  }), !person.payment_intent ? undefined : stripe.refunds.create({\n    payment_intent: person.payment_intent\n  })]);\n  return {\n    status: 200,\n    result: {\n      payment_intent: person.payment_intent,\n      person: person.person\n    }\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/cohorts/[cohortId]/enroll.ts"],"names":["rt","APIHandler","stripe","sendCohortEnrollmentEmail","sendEnrollNotificationEmaill","sendUnenrollEmail","getToken","addMember","getTaggedPost","DISCOURSE_URL","prettyDate","prisma","POST","enroll","DELETE","unenroll","EnrollMsgValidator","Record","discount","Union","Undefined","String","paystack","Boolean","UnEnrollMsgValidator","person","req","cohortId","parseInt","query","Number","isNaN","status","result","user","msg","check","body","e","toString","cohort","Promise","all","course_cohorts","findUnique","where","id","include","discourse_groups","cohort_facilitators","select","people","email","courses","course_groupTodiscourse_groups","invite_only","category_id","cost","slug","name","course_invites","course_discounts","code","undefined","deleted","max_redeems","redeems","message","length","origin","URL","headers","referer","price","type","amount","Math","floor","gettingStarted","update","data","increment","people_in_cohorts","create","amount_paid","connect","username","display_name","course_start_date","start_date","course_name","cohort_page_url","course","cohort_forum_url","get_started_topic_url","map","f","learner","zeroCost","metadata","userId","session","checkout","sessions","payment_method_types","customer","stripe_customer_id","customer_email","payment_intent_data","transfer_group","line_items","currency","quantity","cancel_url","success_url","sessionId","payment_intent","find","facilitator","p","paid","delete","person_cohort","refunds","cohort_refunds"],"mappings":"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","sourcesContent":["import * as rt from \"runtypes\";\nimport { ResultType, APIHandler, Request } from \"src/apiHelpers\";\nimport { StripePaymentMetaData, stripe } from \"src/stripe\";\nimport {\n  sendCohortEnrollmentEmail,\n  sendEnrollNotificationEmaill,\n  sendUnenrollEmail,\n} from \"emails\";\nimport { getToken } from \"src/token\";\nimport { addMember, getTaggedPost } from \"src/discourse\";\nimport { DISCOURSE_URL } from \"src/constants\";\nimport { prettyDate } from \"src/utils\";\nimport prisma from \"lib/prisma\";\n\nexport type EnrollResponse = ResultType<typeof enroll>;\nexport type EnrollMsg = rt.Static<typeof EnrollMsgValidator>;\nexport type UnEnrollMsg = rt.Static<typeof UnEnrollMsgValidator>;\nexport type UnEnrollResponse = ResultType<typeof unenroll>;\n\nexport default APIHandler({\n  POST: enroll,\n  DELETE: unenroll,\n});\n\nlet EnrollMsgValidator = rt.Record({\n  discount: rt.Union(rt.Undefined, rt.String),\n  paystack: rt.Union(rt.Undefined, rt.Boolean),\n});\n\nlet UnEnrollMsgValidator = rt.Record({\n  person: rt.String,\n});\n\nasync function enroll(req: Request) {\n  let cohortId = parseInt(req.query.cohortId as string);\n  if (Number.isNaN(cohortId))\n    return { status: 400, result: \"ERROR: Cohort id is not a number\" } as const;\n  let user = getToken(req);\n  if (!user)\n    return { status: 401, result: \"Error: no user logged in\" } as const;\n  let msg;\n  try {\n    msg = EnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return { status: 400, result: e.toString() } as const;\n  }\n  let { paystack } = msg;\n  let [cohort, person, discount] = await Promise.all([\n    prisma.course_cohorts.findUnique({\n      where: { id: cohortId },\n      include: {\n        discourse_groups: true,\n        cohort_facilitators: {\n          select: { people: { select: { email: true } } },\n        },\n        courses: {\n          select: {\n            course_groupTodiscourse_groups: true,\n            invite_only: true,\n            category_id: true,\n            cost: true,\n            slug: true,\n            name: true,\n            course_invites: {\n              where: {\n                email: user.email,\n              },\n            },\n          },\n        },\n      },\n    }),\n    prisma.people.findUnique({ where: { id: user.id } }),\n    msg.discount\n      ? prisma.course_discounts.findUnique({ where: { code: msg.discount } })\n      : null,\n  ]);\n\n  if (!cohort || cohort.courses.cost === undefined)\n    return {\n      status: 400,\n      result: \"Error: no cohort with id \" + cohortId + \" found\",\n    } as const;\n  if (msg.discount && (!discount || discount.deleted))\n    return { status: 404, result: { discount: msg.discount } } as const;\n  if (\n    discount &&\n    discount.max_redeems !== 0 &&\n    discount.max_redeems <= discount.redeems\n  )\n    return {\n      status: 403,\n      result: {\n        message: \"ERROR: Discount code has no uses left\",\n        discount: msg.discount,\n      },\n    } as const;\n\n  if (\n    cohort.courses.invite_only &&\n    cohort.courses.course_invites.length === 0\n  ) {\n    return {\n      status: 401,\n      result: \"ERROR: Course is invite_only and user is not invited\",\n    } as const;\n  }\n\n  let origin = new URL(req.headers.referer || \"\").origin;\n  let price = cohort.courses.cost;\n  if (discount) {\n    if (discount.type === \"absolute\") price = price - discount.amount;\n    else price = price - Math.floor((discount.amount / 100) * price);\n  }\n  if (price === 0) {\n    let gettingStarted = await getTaggedPost(\n      cohort.category_id,\n      \"getting-started\"\n    );\n    await Promise.all([\n      discount\n        ? prisma.course_discounts.update({\n            where: { code: discount.code },\n            data: { redeems: { increment: 1 } },\n          })\n        : null,\n      prisma.people_in_cohorts.create({\n        data: {\n          amount_paid: 0,\n          people: { connect: { id: user.id } },\n          course_cohorts: { connect: { id: cohortId } },\n          course_discounts: discount\n            ? { connect: { code: discount.code } }\n            : undefined,\n        },\n      }),\n      addMember(cohort.discourse_groups.id, user.username),\n      addMember(\n        cohort.courses.course_groupTodiscourse_groups.id,\n        user.username\n      ),\n      sendCohortEnrollmentEmail(user.email, {\n        name: user.display_name || user.username,\n        course_start_date: prettyDate(cohort.start_date),\n        course_name: cohort.courses.name,\n        cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n        cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n        get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`,\n      }),\n      Promise.all([\n        cohort.cohort_facilitators.map(\n          async (f) =>\n            person &&\n            cohort &&\n            sendEnrollNotificationEmaill(f.people.email, {\n              learner: person.display_name || person.username,\n              course: cohort.courses.name,\n              cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n              cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n            })\n        ),\n      ]),\n    ]);\n    return {\n      status: 200,\n      result: { zeroCost: true } as const,\n    };\n  }\n  //TO DO: get the price of naira per hour and save in separate mongo db\n  let metadata: StripePaymentMetaData = {\n    type: \"cohort\",\n    cohortId: cohort.id.toString(),\n    userId: user.id,\n    discount: discount?.code || null,\n  };\n\n  if (paystack) {\n    return {\n      status: 200,\n      result: {\n        amount: price * 400 * 100,\n        email: user.email,\n        metadata,\n      } as const,\n    };\n  }\n\n  const session = await stripe.checkout.sessions.create({\n    payment_method_types: [\"card\"],\n    customer: person?.stripe_customer_id || undefined,\n    customer_email: person?.stripe_customer_id ? undefined : user.email,\n    payment_intent_data: {\n      transfer_group: cohort.id.toString(),\n    },\n    line_items: [\n      {\n        name:\n          cohort.courses.name +\n          (discount\n            ? `, ${\n                discount?.type === \"absolute\"\n                  ? \"$\" + discount?.amount\n                  : discount?.amount + \"%\"\n              } Off`\n            : \"\"),\n        amount: price * 100,\n        currency: \"usd\",\n        quantity: 1,\n        //TO DO: Add discount\n      },\n    ],\n    cancel_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n    success_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}?welcome`,\n    metadata,\n  });\n\n  return {\n    status: 200,\n    result: { sessionId: session.id },\n  } as const;\n}\nasync function unenroll(req: Request) {\n  let cohortId = parseInt(req.query.cohortId as string);\n  if (Number.isNaN(cohortId))\n    return { status: 400, result: \"ERROR: Cohort id is not a number\" } as const;\n  let user = getToken(req);\n  if (!user)\n    return { status: 401, result: \"Error: no user logged in\" } as const;\n\n  let msg: UnEnrollMsg;\n  try {\n    msg = UnEnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return { status: 400, result: e.toString() } as const;\n  }\n\n  let [cohort] = await Promise.all([\n    prisma.course_cohorts.findUnique({\n      where: { id: cohortId },\n      select: {\n        cohort_facilitators: true,\n        courses: {\n          select: {\n            name: true,\n          },\n        },\n        discourse_groups: true,\n        people: {\n          select: { email: true },\n        },\n        people_in_cohorts: {\n          select: {\n            person: true,\n            payment_intent: true,\n            amount_paid: true,\n            people: {\n              select: { display_name: true, email: true, username: true },\n            },\n          },\n        },\n      },\n    }),\n  ]);\n  if (!cohort)\n    return {\n      status: 404,\n      result: \"ERROR: no cohort found with id: \" + cohortId,\n    } as const;\n  if (\n    !cohort.cohort_facilitators.find((f) => user && f.facilitator === user.id)\n  )\n    return {\n      status: 401,\n      result: `ERROR: User is not facilitator of cohort`,\n    } as const;\n\n  let person = cohort.people_in_cohorts.find((p) => p.person === msg.person);\n  if (!person)\n    return { status: 404, result: \"ERROR: User is not in cohort\" } as const;\n  if (!person.payment_intent && person.amount_paid !== 0)\n    return {\n      status: 500,\n      result:\n        \"ERROR: Amount paid is greater than zero but there is not payment information\",\n    } as const;\n  // TO DO check what payment_intent is\n\n  await Promise.all([\n    sendUnenrollEmail(person.people.email, {\n      name: person.people.display_name || person.people.username,\n      course_name: cohort.courses.name,\n      paid: person.amount_paid > 0 ? \"true\" : \"\",\n    }),\n    prisma.people_in_cohorts.delete({\n      where: {\n        person_cohort: {\n          person: msg.person,\n          cohort: cohortId,\n        },\n      },\n    }),\n    !person.payment_intent\n      ? undefined\n      : prisma.refunds.create({\n          data: {\n            payment_intent: person.payment_intent,\n            amount: person.amount_paid,\n            cohort_refunds: {\n              create: {\n                course_cohorts: {\n                  connect: {\n                    id: cohortId,\n                  },\n                },\n                people: {\n                  connect: { id: person.person },\n                },\n              },\n            },\n          },\n        }),\n    !person.payment_intent\n      ? undefined\n      : stripe.refunds.create({ payment_intent: person.payment_intent }),\n  ]);\n\n  return {\n    status: 200,\n    result: { payment_intent: person.payment_intent, person: person.person },\n  } as const;\n}\n"]},"metadata":{},"sourceType":"module"}