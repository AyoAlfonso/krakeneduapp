{"ast":null,"code":"import { multiRouteHandler } from 'src/apiHelpers';\nimport hmac from 'src/hmac';\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\nimport { sendResetPasswordEmail } from 'emails';\nimport prisma from \"lib/prisma\";\nexport default multiRouteHandler('action', {\n  request: requestResetPassword,\n  reset: resetPassword\n});\n\nasync function requestResetPassword(req) {\n  let msg = req.body;\n\n  if (!msg.email) {\n    return {\n      status: 403,\n      result: \"Error: invalid request, missing email\"\n    };\n  }\n\n  let user = await findUser(msg.email);\n\n  if (!user) {\n    return {\n      status: 200,\n      result: \"\"\n    };\n  } else {\n    let key = await createResetKey(msg.email);\n    let origin = new URL(req.headers.referer || '').origin;\n    let url = `${origin}/resetPassword?&key=${key}`;\n    await sendResetPasswordEmail(msg.email, {\n      action_url: url,\n      name: user.display_name || user.username\n    });\n    return {\n      status: 200,\n      result: \"\"\n    };\n  }\n}\n\nasync function resetPassword(req) {\n  let msg = req.body;\n\n  if (!msg.key || !msg.password) {\n    return {\n      status: 400,\n      result: \"Error: invalid message, missing key or new password\"\n    };\n  }\n\n  let hash = hmac(msg.key);\n  let resetKey = await getResetKey(hash);\n\n  if (!resetKey) {\n    return {\n      status: 403,\n      result: \"Error: invalid reset key\"\n    };\n  }\n\n  let date = new Date(resetKey.created_time);\n\n  if ((Date.now() - date.getTime()) / (1000 * 60) > 30) {\n    return {\n      status: 403,\n      result: \"Error: password reset key out of date\"\n    };\n  }\n\n  await updatePassword(resetKey.email, msg.password, hash);\n  return {\n    status: 200,\n    result: ''\n  };\n}\n\nasync function getResetKey(hash) {\n  return prisma.password_reset_keys.findUnique({\n    where: {\n      key_hash: hash\n    }\n  });\n}\n\nconst createResetKey = async email => {\n  let key = uuidv4();\n  await prisma.password_reset_keys.create({\n    data: {\n      email,\n      created_time: new Date(Date.now()).toISOString(),\n      key_hash: hmac(key)\n    }\n  });\n  return key;\n};\n\nconst findUser = async email => {\n  return await prisma.people.findUnique({\n    where: {\n      email\n    }\n  });\n};\n\nexport async function updatePassword(email, newPassword, key_hash) {\n  let password_hash = await bcrypt.hash(newPassword, await bcrypt.genSalt());\n  await prisma.password_reset_keys.delete({\n    where: {\n      key_hash\n    }\n  });\n  return prisma.people.update({\n    where: {\n      email\n    },\n    data: {\n      password_hash\n    }\n  });\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/user/resetPassword/[action].ts"],"names":["multiRouteHandler","hmac","v4","uuidv4","bcrypt","sendResetPasswordEmail","prisma","request","requestResetPassword","reset","resetPassword","req","msg","body","email","status","result","user","findUser","key","createResetKey","origin","URL","headers","referer","url","action_url","name","display_name","username","password","hash","resetKey","getResetKey","date","Date","created_time","now","getTime","updatePassword","password_reset_keys","findUnique","where","key_hash","create","data","toISOString","people","newPassword","password_hash","genSalt","delete","update"],"mappings":"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","sourcesContent":["import {multiRouteHandler, ResultType, Request} from 'src/apiHelpers'\nimport hmac from 'src/hmac'\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs'\nimport {sendResetPasswordEmail} from 'emails'\nimport prisma from \"lib/prisma\";\n\nexport type RequestMsg = {\n  email: string\n}\n\nexport type ResetMsg = {\n  key: string\n  password: string\n}\n\nexport type RequestResult = ResultType<typeof requestResetPassword>\nexport type ResetResult = ResultType<typeof resetPassword>\n\nexport default multiRouteHandler('action', {\n  request: requestResetPassword,\n  reset: resetPassword\n})\n\nasync function requestResetPassword (req:Request) {\n  let msg = req.body as Partial<RequestMsg>\n  if(!msg.email) {\n    return {status: 403, result: \"Error: invalid request, missing email\"} as const\n  }\n\n  let user = await findUser(msg.email)\n  if(!user) {\n    return {status: 200, result: \"\"} as const\n  }\n\n  else {\n    let key = await createResetKey(msg.email)\n\n    let origin = (new URL(req.headers.referer || '')).origin\n    let url = `${origin}/resetPassword?&key=${key}`\n\n    await sendResetPasswordEmail(msg.email, {\n      action_url: url,\n      name: user.display_name || user.username\n    })\n    return {status: 200, result: \"\"} as const\n  }\n}\n\nasync function resetPassword (req:Request) {\n  let msg = req.body as Partial<ResetMsg>\n  if(!msg.key || !msg.password) {\n    return {\n      status: 400,\n      result: \"Error: invalid message, missing key or new password\"\n    } as const\n  }\n\n  let hash = hmac(msg.key)\n  let resetKey = await getResetKey(hash)\n  if(!resetKey) {\n    return {\n      status: 403,\n      result: \"Error: invalid reset key\"\n    } as const\n  }\n\n  let date = new Date(resetKey.created_time)\n\n  if((Date.now() - date.getTime())/(1000 * 60) > 30)  {\n    return {\n      status: 403,\n      result: \"Error: password reset key out of date\"\n    } as const\n  }\n\n  await updatePassword(resetKey.email, msg.password, hash)\n  return {status: 200, result:''}\n}\n\nasync function getResetKey(hash: string) {\n  return prisma.password_reset_keys.findUnique({where:{key_hash:hash}})\n}\n\n\nconst createResetKey = async (email: string) => {\n  let key = uuidv4()\n  await prisma.password_reset_keys.create({data:{\n      email,\n      created_time: new Date(Date.now()).toISOString(),\n      key_hash: hmac(key)\n  }})\n  return key\n}\n\nconst findUser = async (email:string) => {\n  return await prisma.people.findUnique({where: {email}})\n}\n\n\nexport async function updatePassword(email: string, newPassword: string, key_hash: string) {\n  let password_hash = await bcrypt.hash(newPassword, await bcrypt.genSalt())\n\n  await prisma.password_reset_keys.delete({where:{key_hash}})\n  return prisma.people.update({where:{email}, data:{password_hash}})\n}\n"]},"metadata":{},"sourceType":"module"}