{"ast":null,"code":"import * as rt from 'runtypes';\nimport { APIHandler } from \"src/apiHelpers\";\nimport { stripe } from 'src/stripe';\nimport { sendCohortEnrollmentEmail, sendEnrollNotificationEmaill, sendUnenrollEmail } from 'emails';\nimport { getToken } from \"src/token\";\nimport { addMember, getTaggedPost } from \"src/discourse\";\nimport { DISCOURSE_URL } from 'src/constants';\nimport { prettyDate } from \"src/utils\";\nimport prisma from \"lib/prisma\";\nexport default APIHandler({\n  POST: enroll,\n  DELETE: unenroll\n});\nlet EnrollMsgValidator = rt.Record({\n  discount: rt.Union(rt.Undefined, rt.String),\n  paystack: rt.Union(rt.Undefined, rt.Boolean)\n});\nlet UnEnrollMsgValidator = rt.Record({\n  person: rt.String\n});\n\nasync function enroll(req) {\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"Error: no user logged in\"\n  };\n  let msg;\n\n  try {\n    msg = EnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let {\n    paystack\n  } = msg;\n  let [cohort, person, discount] = await Promise.all([prisma.course_cohorts.findUnique({\n    where: {\n      id: cohortId\n    },\n    include: {\n      discourse_groups: true,\n      cohort_facilitators: {\n        select: {\n          people: {\n            select: {\n              email: true\n            }\n          }\n        }\n      },\n      courses: {\n        select: {\n          course_groupTodiscourse_groups: true,\n          invite_only: true,\n          category_id: true,\n          cost: true,\n          slug: true,\n          name: true,\n          course_invites: {\n            where: {\n              email: user.email\n            }\n          }\n        }\n      }\n    }\n  }), prisma.people.findUnique({\n    where: {\n      id: user.id\n    }\n  }), msg.discount ? prisma.course_discounts.findUnique({\n    where: {\n      code: msg.discount\n    }\n  }) : null]);\n  if (!cohort || cohort.courses.cost === undefined) return {\n    status: 400,\n    result: \"Error: no cohort with id \" + cohortId + \" found\"\n  };\n  if (msg.discount && (!discount || discount.deleted)) return {\n    status: 404,\n    result: {\n      discount: msg.discount\n    }\n  };\n  if (discount && discount.max_redeems !== 0 && discount.max_redeems <= discount.redeems) return {\n    status: 403,\n    result: {\n      message: \"ERROR: Discount code has no uses left\",\n      discount: msg.discount\n    }\n  };\n\n  if (cohort.courses.invite_only && cohort.courses.course_invites.length === 0) {\n    return {\n      status: 401,\n      result: \"ERROR: Course is invite_only and user is not invited\"\n    };\n  }\n\n  let origin = new URL(req.headers.referer || '').origin;\n  let price = cohort.courses.cost;\n\n  if (discount) {\n    if (discount.type === 'absolute') price = price - discount.amount;else price = price - Math.floor(discount.amount / 100 * price);\n  }\n\n  if (price === 0) {\n    let gettingStarted = await getTaggedPost(cohort.category_id, 'getting-started');\n    await Promise.all([discount ? prisma.course_discounts.update({\n      where: {\n        code: discount.code\n      },\n      data: {\n        redeems: {\n          increment: 1\n        }\n      }\n    }) : null, prisma.people_in_cohorts.create({\n      data: {\n        amount_paid: 0,\n        people: {\n          connect: {\n            id: user.id\n          }\n        },\n        course_cohorts: {\n          connect: {\n            id: cohortId\n          }\n        },\n        course_discounts: discount ? {\n          connect: {\n            code: discount.code\n          }\n        } : undefined\n      }\n    }), addMember(cohort.discourse_groups.id, user.username), addMember(cohort.courses.course_groupTodiscourse_groups.id, user.username), sendCohortEnrollmentEmail(user.email, {\n      name: user.display_name || user.username,\n      course_start_date: prettyDate(cohort.start_date),\n      course_name: cohort.courses.name,\n      cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n      cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n      get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`\n    }), Promise.all([cohort.cohort_facilitators.map(async (f) => person && cohort && sendEnrollNotificationEmaill(f.people.email, {\n      learner: person.display_name || person.username,\n      course: cohort.courses.name,\n      cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n      cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`\n    }))])]);\n    return {\n      status: 200,\n      result: {\n        zeroCost: true\n      }\n    };\n  } //TO DO: get the price of naira per hour and save in separate mongo db\n\n\n  let metadata = {\n    type: 'cohort',\n    cohortId: cohort.id.toString(),\n    userId: user.id,\n    discount: (discount === null || discount === void 0 ? void 0 : discount.code) || null\n  };\n\n  if (paystack) {\n    return {\n      status: 200,\n      result: {\n        amount: price * 400 * 100,\n        email: user.email,\n        metadata\n      }\n    };\n  }\n\n  const session = await stripe.checkout.sessions.create({\n    payment_method_types: ['card'],\n    customer: (person === null || person === void 0 ? void 0 : person.stripe_customer_id) || undefined,\n    customer_email: person !== null && person !== void 0 && person.stripe_customer_id ? undefined : user.email,\n    payment_intent_data: {\n      transfer_group: cohort.id.toString()\n    },\n    line_items: [{\n      name: cohort.courses.name + (discount ? `, ${(discount === null || discount === void 0 ? void 0 : discount.type) === 'absolute' ? '$' + (discount === null || discount === void 0 ? void 0 : discount.amount) : (discount === null || discount === void 0 ? void 0 : discount.amount) + \"%\"} Off` : ''),\n      amount: price * 100,\n      currency: 'usd',\n      quantity: 1 //TO DO: Add discount \n\n    }],\n    cancel_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n    success_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}?welcome`,\n    metadata\n  });\n  return {\n    status: 200,\n    result: {\n      sessionId: session.id\n    }\n  };\n}\n\nasync function unenroll(req) {\n  let cohortId = parseInt(req.query.cohortId);\n  if (Number.isNaN(cohortId)) return {\n    status: 400,\n    result: \"ERROR: Cohort id is not a number\"\n  };\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"Error: no user logged in\"\n  };\n  let msg;\n\n  try {\n    msg = UnEnrollMsgValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let [cohort] = await Promise.all([prisma.course_cohorts.findUnique({\n    where: {\n      id: cohortId\n    },\n    select: {\n      cohort_facilitators: true,\n      courses: {\n        select: {\n          name: true\n        }\n      },\n      discourse_groups: true,\n      people: {\n        select: {\n          email: true\n        }\n      },\n      people_in_cohorts: {\n        select: {\n          person: true,\n          payment_intent: true,\n          amount_paid: true,\n          people: {\n            select: {\n              display_name: true,\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    }\n  })]);\n  if (!cohort) return {\n    status: 404,\n    result: \"ERROR: no cohort found with id: \" + cohortId\n  };\n  if (!cohort.cohort_facilitators.find(f => user && f.facilitator === user.id)) return {\n    status: 401,\n    result: `ERROR: User is not facilitator of cohort`\n  };\n  let person = cohort.people_in_cohorts.find(p => p.person === msg.person);\n  if (!person) return {\n    status: 404,\n    result: \"ERROR: User is not in cohort\"\n  };\n  if (!person.payment_intent && person.amount_paid !== 0) return {\n    status: 500,\n    result: \"ERROR: Amount paid is greater than zero but there is not payment information\"\n  }; // TO DO check what payment_intent is\n\n  await Promise.all([sendUnenrollEmail(person.people.email, {\n    name: person.people.display_name || person.people.username,\n    course_name: cohort.courses.name,\n    paid: person.amount_paid > 0 ? 'true' : ''\n  }), prisma.people_in_cohorts.delete({\n    where: {\n      person_cohort: {\n        person: msg.person,\n        cohort: cohortId\n      }\n    }\n  }), !person.payment_intent ? undefined : prisma.refunds.create({\n    data: {\n      payment_intent: person.payment_intent,\n      amount: person.amount_paid,\n      cohort_refunds: {\n        create: {\n          course_cohorts: {\n            connect: {\n              id: cohortId\n            }\n          },\n          people: {\n            connect: {\n              id: person.person\n            }\n          }\n        }\n      }\n    }\n  }), !person.payment_intent ? undefined : stripe.refunds.create({\n    payment_intent: person.payment_intent\n  })]);\n  return {\n    status: 200,\n    result: {\n      payment_intent: person.payment_intent,\n      person: person.person\n    }\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/cohorts/[cohortId]/enroll.ts"],"names":["rt","APIHandler","stripe","sendCohortEnrollmentEmail","sendEnrollNotificationEmaill","sendUnenrollEmail","getToken","addMember","getTaggedPost","DISCOURSE_URL","prettyDate","prisma","POST","enroll","DELETE","unenroll","EnrollMsgValidator","Record","discount","Union","Undefined","String","paystack","Boolean","UnEnrollMsgValidator","person","req","cohortId","parseInt","query","Number","isNaN","status","result","user","msg","check","body","e","toString","cohort","Promise","all","course_cohorts","findUnique","where","id","include","discourse_groups","cohort_facilitators","select","people","email","courses","course_groupTodiscourse_groups","invite_only","category_id","cost","slug","name","course_invites","course_discounts","code","undefined","deleted","max_redeems","redeems","message","length","origin","URL","headers","referer","price","type","amount","Math","floor","gettingStarted","update","data","increment","people_in_cohorts","create","amount_paid","connect","username","display_name","course_start_date","start_date","course_name","cohort_page_url","course","cohort_forum_url","get_started_topic_url","map","f","learner","zeroCost","metadata","userId","session","checkout","sessions","payment_method_types","customer","stripe_customer_id","customer_email","payment_intent_data","transfer_group","line_items","currency","quantity","cancel_url","success_url","sessionId","payment_intent","find","facilitator","p","paid","delete","person_cohort","refunds","cohort_refunds"],"mappings":"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","sourcesContent":["import * as rt from 'runtypes'\nimport { ResultType, APIHandler, Request } from \"src/apiHelpers\"\nimport {StripePaymentMetaData, stripe} from 'src/stripe'\nimport { sendCohortEnrollmentEmail, sendEnrollNotificationEmaill, sendUnenrollEmail } from 'emails'\nimport { getToken } from \"src/token\";\nimport { addMember, getTaggedPost } from \"src/discourse\";\nimport {DISCOURSE_URL} from 'src/constants'\nimport { prettyDate } from \"src/utils\"\nimport prisma from \"lib/prisma\";\n\n\nexport type EnrollResponse= ResultType<typeof enroll>\nexport type EnrollMsg  = rt.Static<typeof EnrollMsgValidator>\nexport type UnEnrollMsg = rt.Static<typeof UnEnrollMsgValidator>\nexport type UnEnrollResponse=ResultType<typeof unenroll>\n\nexport default APIHandler({\n  POST: enroll,\n  DELETE: unenroll\n})\n\nlet EnrollMsgValidator = rt.Record({\n  discount: rt.Union(rt.Undefined, rt.String),\n  paystack: rt.Union(rt.Undefined, rt.Boolean)\n})\n\nlet UnEnrollMsgValidator = rt.Record({\n  person: rt.String,\n})\n\nasync function enroll (req: Request) {\n  let cohortId = parseInt(req.query.cohortId as string)\n  if(Number.isNaN(cohortId)) return {status: 400, result: \"ERROR: Cohort id is not a number\"} as const\n  let user = getToken(req)\n  if(!user) return {status: 401, result: \"Error: no user logged in\"} as const\n  let msg\n  try {msg = EnrollMsgValidator.check(req.body)}\n  catch(e) {return {status:400, result:e.toString()} as const }\n  let {paystack} = msg\n  let [cohort, person, discount] = await Promise.all([\n    prisma.course_cohorts.findUnique({\n      where: {id: cohortId},\n      include: {\n        discourse_groups: true,\n        cohort_facilitators:{select:{people:{select:{email: true}}}},\n        courses: {\n          select: {\n            course_groupTodiscourse_groups: true,\n            invite_only: true,\n            category_id: true,\n            cost: true,\n            slug: true,\n            name: true,\n            course_invites:{\n              where: {\n                email: user.email\n              }\n            }\n          }\n        }\n      }\n    }),\n    prisma.people.findUnique({where:{id:user.id}}),\n    msg.discount ? prisma.course_discounts.findUnique({where: {code: msg.discount}}) : null\n  ])\n\n  if(!cohort || cohort.courses.cost === undefined) return {status: 400, result: \"Error: no cohort with id \" + cohortId + \" found\"}  as const\n  if(msg.discount && (!discount || discount.deleted)) return {status: 404, result: {discount: msg.discount}} as const\n  if(discount && discount.max_redeems !== 0 &&discount.max_redeems <= discount.redeems) return {\n    status: 403,\n    result: {\n      message: \"ERROR: Discount code has no uses left\",\n      discount: msg.discount\n    }\n  } as const\n\n  if(cohort.courses.invite_only && cohort.courses.course_invites.length === 0){\n    return {status: 401, result: \"ERROR: Course is invite_only and user is not invited\"} as const\n  }\n\n  let origin = (new URL(req.headers.referer || '')).origin\n  let price = cohort.courses.cost\n  if(discount) {\n    if(discount.type === 'absolute') price = price - discount.amount\n    else price = price - (Math.floor((discount.amount/100)*price))\n  }\n  if(price === 0) {\n    let gettingStarted = await getTaggedPost(cohort.category_id, 'getting-started')\n    await Promise.all([\n      discount\n        ? prisma.course_discounts.update({\n            where: { code: discount.code },\n            data: { redeems: { increment: 1 } },\n          })\n        : null,\n      prisma.people_in_cohorts.create({\n        data: {\n          amount_paid: 0,\n          people: { connect: { id: user.id } },\n          course_cohorts: { connect: { id: cohortId } },\n          course_discounts: discount\n            ? { connect: { code: discount.code } }\n            : undefined,\n        },\n      }),\n      addMember(cohort.discourse_groups.id, user.username),\n      addMember(\n        cohort.courses.course_groupTodiscourse_groups.id,\n        user.username\n      ),\n      sendCohortEnrollmentEmail(user.email, {\n        name: user.display_name || user.username,\n        course_start_date: prettyDate(cohort.start_date),\n        course_name: cohort.courses.name,\n        cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n        cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n        get_started_topic_url: `${DISCOURSE_URL}/t/${gettingStarted.id}`,\n      }),\n      Promise.all([\n        cohort.cohort_facilitators.map(\n          async (f) =>\n            person &&\n            cohort &&\n            sendEnrollNotificationEmaill(f.people.email, {\n              learner: person.display_name || person.username,\n              course: cohort.courses.name,\n              cohort_page_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n              cohort_forum_url: `${DISCOURSE_URL}/session/sso?return_path=/c/${cohort.category_id}`,\n            })\n        ),\n      ]),\n    ]);\n    return {\n      status: 200,\n      result: {zeroCost: true} as const\n    }\n  }\n //TO DO: get the price of naira per hour and save in separate mongo db\n     let metadata: StripePaymentMetaData = {\n      type: 'cohort',\n      cohortId: cohort.id.toString(),\n      userId: user.id,\n      discount: discount?.code || null\n    }\n\n    if(paystack)  {\n        return {\n        status: 200,\n        result: {amount: price * 400 * 100, email: user.email, metadata} as const\n      }\n    } \n\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      customer: person?.stripe_customer_id || undefined,\n      customer_email: person?.stripe_customer_id ? undefined : user.email,\n      payment_intent_data: {\n        transfer_group: cohort.id.toString()\n      },\n      line_items: [{\n        name: cohort.courses.name +\n          (discount ? `, ${discount?.type === 'absolute' ? '$'+discount?.amount : discount?.amount+\"%\"} Off` : ''),\n        amount: price * 100,\n        currency: 'usd',\n        quantity: 1,\n        //TO DO: Add discount \n      }],\n      cancel_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}`,\n      success_url: `${origin}/courses/${cohort.courses.slug}/${cohort.course}/cohorts/${cohort.id}?welcome`,\n      metadata\n    });\n\n    return {\n      status: 200,\n      result: {sessionId: session.id}\n    } as const\n \n}\nasync function unenroll (req: Request) {\n  let cohortId = parseInt(req.query.cohortId as string)\n  if(Number.isNaN(cohortId)) return {status: 400, result: \"ERROR: Cohort id is not a number\"} as const\n  let user = getToken(req)\n  if(!user) return {status: 401, result: \"Error: no user logged in\"} as const\n\n  let msg:UnEnrollMsg\n  try {msg = UnEnrollMsgValidator.check(req.body)}\n  catch(e) {return {status:400, result:e.toString()} as const }\n\n  let [cohort] = await Promise.all([\n    prisma.course_cohorts.findUnique({\n      where: {id: cohortId},\n      select: {\n        cohort_facilitators: true,\n        courses:{\n          select:{\n            name: true\n          }\n        },\n        discourse_groups: true,\n        people: {\n          select:{email: true}\n        },\n        people_in_cohorts: {\n          select: {person: true, payment_intent: true, amount_paid: true, people:{select:{display_name: true, email: true, username: true}}}\n        }\n      }\n    }),\n  ])\n  if(!cohort) return {status:404, result:\"ERROR: no cohort found with id: \"+cohortId} as const\n  if(!cohort.cohort_facilitators.find(f=>user&&f.facilitator===user.id)) return {status:401, result:`ERROR: User is not facilitator of cohort`} as const\n\n  let person = cohort.people_in_cohorts.find(p=>p.person===msg.person)\n  if(!person) return {status:404, result: \"ERROR: User is not in cohort\"} as const\n  if(!person.payment_intent && person.amount_paid !== 0) return {status: 500, result: \"ERROR: Amount paid is greater than zero but there is not payment information\"} as const\n  // TO DO check what payment_intent is\n\n  await Promise.all([\n    sendUnenrollEmail(person.people.email, {\n      name: person.people.display_name || person.people.username,\n      course_name:  cohort.courses.name,\n      paid: person.amount_paid > 0 ? 'true' : ''\n    }),\n    prisma.people_in_cohorts.delete({where:{person_cohort:{\n      person: msg.person,\n      cohort: cohortId\n    }}}),\n    !person.payment_intent ? undefined : prisma.refunds.create({\n      data:{\n        payment_intent: person.payment_intent,\n        amount: person.amount_paid,\n        cohort_refunds: {\n          create:{\n            course_cohorts: {\n              connect:{\n                id: cohortId\n              }\n            },\n            people:{\n              connect: {id: person.person}\n            }\n          }\n        }\n      }\n    }),\n   !person.payment_intent ? undefined : stripe.refunds.create({payment_intent: person.payment_intent})\n  ])\n\n  return {status: 200, result: {payment_intent: person.payment_intent, person: person.person}} as const\n\n}\n"]},"metadata":{},"sourceType":"module"}