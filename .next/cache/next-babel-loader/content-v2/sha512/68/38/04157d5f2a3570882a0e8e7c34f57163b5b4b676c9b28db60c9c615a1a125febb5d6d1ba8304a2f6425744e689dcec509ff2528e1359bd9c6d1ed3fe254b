{"ast":null,"code":"import h from 'react-hyperscript';\nimport querystring from 'querystring';\nimport crypto from 'crypto';\nimport { useRouter } from 'next/router';\nimport { getToken } from 'src/token';\nimport { makeSSOPayload } from 'src/discourse';\nimport { DISCOURSE_URL } from 'src/constants';\n\nconst SSO = ({\n  error\n}) => {\n  let router = useRouter();\n  let {\n    sso,\n    sig\n  } = router.query;\n  if (!sso || !sig) return h('div', 'Invalid SSO parameters!');\n  if (error) return h('p', 'An error occured, please check with the reffering site');\n  return h('h1', 'Logging you onto discourse...');\n};\n\nexport default SSO;\nexport const getServerSideProps = async ({\n  req,\n  res,\n  query\n}) => {\n  let token = getToken(req);\n\n  if (!token) {\n    res.writeHead(301, {\n      Location: '/login?redirect=' + encodeURIComponent(req.url)\n    });\n    res.end();\n    return {\n      props: {}\n    };\n  }\n\n  let {\n    sso,\n    sig\n  } = query;\n  if (typeof sso !== 'string') return {\n    props: {\n      error: true\n    }\n  };\n  const hmac1 = crypto.createHmac('sha256', process.env.DISCOURSE_SECRET || '');\n  hmac1.update(Buffer.from(sso));\n  let verifySig = hmac1.digest('hex');\n  if (verifySig !== sig) return {\n    props: {\n      error: true\n    }\n  };\n  let {\n    nonce\n  } = querystring.parse(Buffer.from(sso, 'base64').toString());\n  res.writeHead(301, {\n    Location: `${DISCOURSE_URL}/session/sso_login?` + makeSSOPayload({\n      nonce: nonce,\n      email: token.email,\n      external_id: token.id\n    })\n  });\n  res.end();\n  return {\n    props: {}\n  };\n};","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/sso.ts"],"names":["h","querystring","crypto","useRouter","getToken","makeSSOPayload","DISCOURSE_URL","SSO","error","router","sso","sig","query","getServerSideProps","req","res","token","writeHead","Location","encodeURIComponent","url","end","props","hmac1","createHmac","process","env","DISCOURSE_SECRET","update","Buffer","from","verifySig","digest","nonce","parse","toString","email","external_id","id"],"mappings":"AAAA,OAAOA,CAAP,MAAc,mBAAd;AACA,OAAOC,WAAP,MAAwB,aAAxB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SAAQC,SAAR,QAAwB,aAAxB;AAGA,SAAQC,QAAR,QAAuB,WAAvB;AACA,SAAUC,cAAV,QAAgC,eAAhC;AACA,SAAQC,aAAR,QAA4B,eAA5B;;AAGA,MAAMC,GAAG,GAAG,CAAC;AAACC,EAAAA;AAAD,CAAD,KAAmB;AAC7B,MAAIC,MAAM,GAAGN,SAAS,EAAtB;AACA,MAAI;AAACO,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAaF,MAAM,CAACG,KAAxB;AAEA,MAAG,CAACF,GAAD,IAAQ,CAACC,GAAZ,EAAiB,OAAOX,CAAC,CAAC,KAAD,EAAQ,yBAAR,CAAR;AAEjB,MAAGQ,KAAH,EAAU,OAAOR,CAAC,CAAC,GAAD,EAAM,wDAAN,CAAR;AAEV,SAAOA,CAAC,CAAC,IAAD,EAAO,+BAAP,CAAR;AACD,CATD;;AAWA,eAAeO,GAAf;AAEA,OAAO,MAAMM,kBAAqC,GAAG,OAAO;AAACC,EAAAA,GAAD;AAAKC,EAAAA,GAAL;AAAUH,EAAAA;AAAV,CAAP,KAA4B;AAC/E,MAAII,KAAK,GAAGZ,QAAQ,CAACU,GAAD,CAApB;;AACA,MAAG,CAACE,KAAJ,EAAW;AACTD,IAAAA,GAAG,CAACE,SAAJ,CAAc,GAAd,EAAmB;AAACC,MAAAA,QAAQ,EAAE,qBAAmBC,kBAAkB,CAACL,GAAG,CAACM,GAAL;AAAhD,KAAnB;AACAL,IAAAA,GAAG,CAACM,GAAJ;AACA,WAAO;AAACC,MAAAA,KAAK,EAAC;AAAP,KAAP;AACD;;AACD,MAAI;AAACZ,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAaC,KAAjB;AACA,MAAG,OAAOF,GAAP,KAAe,QAAlB,EAA4B,OAAO;AAACY,IAAAA,KAAK,EAAE;AAACd,MAAAA,KAAK,EAAE;AAAR;AAAR,GAAP;AAE5B,QAAMe,KAAK,GAAGrB,MAAM,CAACsB,UAAP,CAAkB,QAAlB,EAA4BC,OAAO,CAACC,GAAR,CAAYC,gBAAZ,IAAgC,EAA5D,CAAd;AACAJ,EAAAA,KAAK,CAACK,MAAN,CAAaC,MAAM,CAACC,IAAP,CAAYpB,GAAZ,CAAb;AAEA,MAAIqB,SAAS,GAAGR,KAAK,CAACS,MAAN,CAAa,KAAb,CAAhB;AACA,MAAGD,SAAS,KAAKpB,GAAjB,EAAsB,OAAQ;AAACW,IAAAA,KAAK,EAAE;AAACd,MAAAA,KAAK,EAAE;AAAR;AAAR,GAAR;AAEtB,MAAI;AAACyB,IAAAA;AAAD,MAAUhC,WAAW,CAACiC,KAAZ,CAAkBL,MAAM,CAACC,IAAP,CAAYpB,GAAZ,EAA2B,QAA3B,EAAqCyB,QAArC,EAAlB,CAAd;AAEApB,EAAAA,GAAG,CAACE,SAAJ,CAAc,GAAd,EAAmB;AACjBC,IAAAA,QAAQ,EAAG,GAAEZ,aAAc,qBAAjB,GACND,cAAc,CAAC;AACf4B,MAAAA,KAAK,EAACA,KADS;AAEfG,MAAAA,KAAK,EAACpB,KAAK,CAACoB,KAFG;AAGfC,MAAAA,WAAW,EAAErB,KAAK,CAACsB;AAHJ,KAAD;AAFD,GAAnB;AAQAvB,EAAAA,GAAG,CAACM,GAAJ;AACA,SAAO;AAACC,IAAAA,KAAK,EAAC;AAAP,GAAP;AAED,CA7BM","sourcesContent":["import h from 'react-hyperscript'\nimport querystring from 'querystring'\nimport crypto from 'crypto'\nimport {useRouter} from 'next/router'\nimport { GetServerSideProps } from 'next'\n\nimport {getToken} from 'src/token'\nimport {  makeSSOPayload } from 'src/discourse'\nimport {DISCOURSE_URL} from 'src/constants'\n\ntype Props = {error:boolean}\nconst SSO = ({error}:Props) => {\n  let router = useRouter()\n  let {sso, sig} = router.query\n\n  if(!sso || !sig) return h('div', 'Invalid SSO parameters!')\n\n  if(error) return h('p', 'An error occured, please check with the reffering site')\n\n  return h('h1', 'Logging you onto discourse...')\n}\n\nexport default SSO\n\nexport const getServerSideProps:GetServerSideProps = async ({req,res, query}) => {\n  let token = getToken(req)\n  if(!token) {\n    res.writeHead(301, {Location: '/login?redirect='+encodeURIComponent(req.url as string)})\n    res.end()\n    return {props:{}}\n  }\n  let {sso, sig} = query\n  if(typeof sso !== 'string') return {props: {error: true}}\n\n  const hmac1 = crypto.createHmac('sha256', process.env.DISCOURSE_SECRET || '');\n  hmac1.update(Buffer.from(sso))\n\n  let verifySig = hmac1.digest('hex')\n  if(verifySig !== sig) return  {props: {error: true}}\n\n  let {nonce} = querystring.parse(Buffer.from(sso as string, 'base64').toString())\n\n  res.writeHead(301, {\n    Location: `${DISCOURSE_URL}/session/sso_login?`\n      + makeSSOPayload({\n        nonce:nonce as string ,\n        email:token.email,\n        external_id: token.id\n      })\n  })\n  res.end()\n  return {props:{}}\n\n}\n"]},"metadata":{},"sourceType":"module"}