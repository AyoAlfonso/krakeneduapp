{"ast":null,"code":"import * as Sentry from '@sentry/node';\nimport { useState, useEffect } from 'react';\nimport useSWR from 'swr';\nexport const APIHandler = handler => {\n  if (process.env.NEXT_PUBLIC_SENTRY_DSN) {\n    Sentry.init({\n      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN\n    });\n  }\n\n  return async (req, res) => {\n    let result;\n\n    try {\n      if (typeof handler === 'object') {\n        let method = req.method;\n        let methodHandler = handler[method];\n\n        if (!methodHandler) {\n          res.status(404).end();\n          return;\n        }\n\n        result = await methodHandler(req);\n      } else {\n        result = await handler(req);\n      }\n    } catch (e) {\n      if (process.env.NEXT_PUBLIC_SENTRY_DSN) {\n        Sentry.captureException(e, {\n          contexts: {\n            headers: req.headers\n          }\n        });\n        await Sentry.flush(2000);\n      }\n\n      console.log(e);\n      return res.status(500).end();\n    }\n\n    if (result.headers) {\n      for (let header of Object.keys(result.headers)) {\n        res.setHeader(header, result.headers[header]);\n      }\n    }\n\n    if (result.status !== 200) console.log(result.result);\n    if (typeof result.result !== 'object') return res.status(result.status).send(result.result);\n    return res.status(result.status).json(result.result);\n  };\n};\nexport const multiRouteHandler = (query, handlers) => {\n  return APIHandler(async req => {\n    let route = typeof req.query[query] === 'string' ? req.query[query] : req.query[query][0];\n    return handlers[route](req);\n  });\n};\nexport async function callApi(endpoint, msg, method) {\n  var _result$headers$get;\n\n  let result = await fetch(endpoint, {\n    method: method ? method : msg ? \"POST\" : \"GET\",\n    headers: {\n      'Content-type': typeof msg === 'object' ? 'application/json' : 'text/html'\n    },\n    body: typeof msg === 'string' ? msg : JSON.stringify(msg)\n  });\n  return {\n    status: result.status,\n    result: (_result$headers$get = result.headers.get('Content-type')) !== null && _result$headers$get !== void 0 && _result$headers$get.includes('application/json') ? await result.json() : await result.text()\n  };\n}\nexport function useApi(deps, successCallback) {\n  let {\n    0: state,\n    1: setState\n  } = useState('normal');\n  useEffect(() => setState('normal'), deps);\n\n  let call = async (path, msg, method) => {\n    setState('loading');\n    let res = await callApi(path, msg, method);\n\n    if (res.status === 200) {\n      if (successCallback) await successCallback(res.result);\n      setState('success');\n    } else setState('error');\n\n    return res;\n  };\n\n  return [state, call, setState];\n}\nexport function useApiData(path, initialData) {\n  return useSWR(path ? path : null, async path => {\n    let res = await callApi(path);\n    if (res.status = 200) return res.result;\n    return res;\n  }, {\n    initialData\n  });\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/src/apiHelpers.ts"],"names":["Sentry","useState","useEffect","useSWR","APIHandler","handler","process","env","NEXT_PUBLIC_SENTRY_DSN","init","dsn","req","res","result","method","methodHandler","status","end","e","captureException","contexts","headers","flush","console","log","header","Object","keys","setHeader","send","json","multiRouteHandler","query","handlers","route","callApi","endpoint","msg","fetch","body","JSON","stringify","get","includes","text","useApi","deps","successCallback","state","setState","call","path","useApiData","initialData"],"mappings":"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","sourcesContent":["import { NextApiRequest, NextApiResponse} from 'next'\nimport * as Sentry from '@sentry/node'\nimport { useState, useEffect} from 'react'\nimport useSWR from 'swr'\n\nexport type ResultType<T extends (...args:any)=> any> = PromiseReturn<ReturnType<T>>\nexport type Request = NextApiRequest\nexport type Success<T extends Result> = Extract<T, {status: 200}>['result']\nexport type Errors<T extends Result> = Exclude<T, {status: 200}>\n\ntype Handler = (req:Request) => Promise<Result>\ntype PromiseReturn<T> = T extends PromiseLike<infer U> ? U : T\n\ntype Result = {\n  status: number,\n  result: string | object | null | boolean\n  headers?: {\n    [key: string]: string | number | string[]\n  }\n}\n\ntype Methods = \"POST\" | \"GET\" | \"PUT\" | \"DELETE\"\n\nexport const APIHandler = (handler: Handler | Partial<{POST: Handler, GET: Handler, PUT: Handler, DELETE: Handler}>) => {\n  if (process.env.NEXT_PUBLIC_SENTRY_DSN) {\n    Sentry.init({ dsn: process.env.NEXT_PUBLIC_SENTRY_DSN});\n  }\n  return async (req:NextApiRequest, res: NextApiResponse) => {\n    let result\n    try {\n      if(typeof handler === 'object') {\n        let method = req.method as Methods\n        let methodHandler = handler[method]\n        if(!methodHandler) {\n          res.status(404).end()\n          return\n        }\n        result = await methodHandler(req)\n      }\n      else {\n        result = await handler(req)\n      }\n    }\n    catch(e) {\n      if (process.env.NEXT_PUBLIC_SENTRY_DSN) {\n        Sentry.captureException(e, {contexts: {headers: req.headers}})\n        await Sentry.flush(2000)\n      }\n      console.log(e)\n      return res.status(500).end()\n    }\n\n    if(result.headers) {\n      for(let header of Object.keys(result.headers)) {\n        res.setHeader(header, result.headers[header])\n      }\n    }\n    if(result.status!==200) console.log(result.result)\n    if(typeof result.result !== 'object') return res.status(result.status).send(result.result)\n    return res.status(result.status).json(result.result)\n  }\n}\n\nexport const multiRouteHandler = (query:string, handlers:{[key:string]: Handler}) => {\n  return APIHandler(async (req) => {\n    let route = (typeof req.query[query] === 'string')\n                 ? req.query[query] as string\n                 : req.query[query][0]\n    return handlers[route](req)\n  })\n}\n\nexport async function callApi<Msg extends object | string | null, R extends Omit<Result, 'headers'>> (endpoint:string, msg?: Msg, method?: Methods){\n    let result = await fetch(endpoint, {\n      method: method ? method : msg ? \"POST\" : \"GET\",\n      headers: {\n        'Content-type': (typeof msg === 'object') ? 'application/json' : 'text/html'\n      },\n      body: (typeof msg === 'string') ? msg : JSON.stringify(msg)\n    })\n\n    return {\n      status: result.status,\n      result: result.headers.get('Content-type')?.includes('application/json')\n        ? await result.json()\n        : await result.text()\n    } as R\n}\n\nexport type Status = 'normal' | 'error' | 'loading' | 'success'\nexport function useApi<Msg extends object | string | null, R extends Omit<Result, 'headers'>>(deps: any[], successCallback?: (result: Extract<R, {status:200}>['result'])=> any) {\n  let [state, setState] = useState<Status>('normal')\n  useEffect(()=> setState('normal'), deps)\n  let call= async (path: string, msg?: Msg, method?: Methods) => {\n    setState('loading')\n    let res = await callApi<Msg, R>(path, msg, method)\n    if(res.status === 200) {\n      if(successCallback) await successCallback(res.result)\n      setState('success')\n    }\n    else setState('error')\n    return res\n  }\n  return [state, call, setState] as const\n}\n\nexport function useApiData<R extends Omit<Result, 'headers'>>(path?: string, initialData?:R) {\n  return useSWR<Success<R>, Errors<R>>(path ? path : null, async (path)=>{\n    let res = await callApi<null, R>(path)\n    if(res.status = 200) return res.result\n    return res\n  }, {initialData})\n}\n"]},"metadata":{},"sourceType":"module"}