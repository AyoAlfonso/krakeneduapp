{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { APIHandler } from \"../../../src/apiHelpers\";\nimport { setTokenHeader, getToken } from '../../../src/token';\nimport { syncSSO } from '../../../src/discourse';\nimport bcrypt from 'bcryptjs';\nexport default APIHandler({\n  POST: updatePerson,\n  GET: getProfileData\n});\n\nasync function updatePerson(req) {\n  let body = req.body;\n  let user = getToken(req);\n\n  if (!user) {\n    return {\n      status: 400,\n      result: \"Error: No user signed in\"\n    };\n  }\n\n  let setHeaders;\n\n  if (body.password) {\n    if (await validateLogin(user.email, body.password.old)) {\n      await updatePassword(user.email, body.password.new);\n    } else {\n      return {\n        status: 401,\n        result: \"Error: Incorrect password\"\n      };\n    }\n  }\n\n  if (body.profile) {\n    let newData = await prisma.people.update({\n      where: {\n        id: user.id\n      },\n      data: {\n        display_name: body.profile.display_name,\n        link: body.profile.link,\n        bio: body.profile.bio,\n        pronouns: body.profile.pronouns\n      }\n    });\n    setHeaders = setTokenHeader(_objectSpread(_objectSpread({}, user), {}, {\n      display_name: newData.display_name,\n      link: newData.link,\n      bio: newData.bio\n    }));\n    await syncSSO({\n      external_id: user.id,\n      email: user.email,\n      username: user.username,\n      name: newData.display_name + (newData.pronouns ? `(${newData.pronouns})` : '') || '',\n      bio: newData.bio || '',\n      website: newData.link || ''\n    });\n  }\n\n  return {\n    status: 200,\n    result: '',\n    headers: setHeaders\n  };\n}\n\nasync function validateLogin(email, password) {\n  try {\n    let person = await prisma.people.findUnique({\n      where: {\n        email\n      }\n    });\n    if (!person) return false;\n    return await bcrypt.compare(password, person.password_hash);\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function updatePassword(email, newPassword) {\n  let password_hash = await bcrypt.hash(newPassword, await bcrypt.genSalt());\n  await prisma.people.update({\n    where: {\n      email\n    },\n    data: {\n      password_hash\n    }\n  });\n}\n\nimport prisma from \"lib/prisma\";\nexport const profileDataQuery = (username, loggedIn) => {\n  return prisma.people.findUnique({\n    where: {\n      username: username\n    },\n    select: {\n      stripe_connected_accounts: loggedIn,\n      calendar_id: loggedIn,\n      pronouns: true,\n      display_name: true,\n      bio: true,\n      link: true\n    }\n  });\n};\n\nasync function getProfileData(req) {\n  let username = req.query.id;\n  let user = getToken(req);\n  if (!username) return {\n    status: 400,\n    result: 'ERROR: no user id provided'\n  };\n  let data = await profileDataQuery(username, (user === null || user === void 0 ? void 0 : user.username) === username);\n  if (!data) return {\n    status: 404,\n    result: `Error: no user with id ${username} found`\n  };\n  return {\n    status: 200,\n    result: data\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/people/[id].ts"],"names":["APIHandler","setTokenHeader","getToken","syncSSO","bcrypt","POST","updatePerson","GET","getProfileData","req","body","user","status","result","setHeaders","password","validateLogin","email","old","updatePassword","new","profile","newData","prisma","people","update","where","id","data","display_name","link","bio","pronouns","external_id","username","name","website","headers","person","findUnique","compare","password_hash","e","newPassword","hash","genSalt","profileDataQuery","loggedIn","select","stripe_connected_accounts","calendar_id","query"],"mappings":"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","sourcesContent":["import { APIHandler, Request, ResultType } from \"../../../src/apiHelpers\";\nimport {setTokenHeader, getToken} from '../../../src/token'\nimport {syncSSO} from '../../../src/discourse'\nimport bcrypt from 'bcryptjs'\n\nexport type UpdatePersonMsg = {\n  profile?: {\n    pronouns?: string\n    display_name?: string,\n    link?: string,\n    bio?: string,\n  },\n  password?: {\n    new: string,\n    old: string\n  },\n}\n\nexport type UpdatePersonResult = ResultType<typeof updatePerson>\nexport type ProfileResult = ResultType<typeof getProfileData>\n\nexport default APIHandler({POST: updatePerson, GET: getProfileData})\n\nasync function updatePerson(req: Request) {\n  let body = req.body as Partial<UpdatePersonMsg>\n  let user = getToken(req)\n  if(!user) {\n    return {\n      status: 400 as const,\n      result: \"Error: No user signed in\" as const\n    }\n  }\n\n  let setHeaders\n  if(body.password) {\n    if(await validateLogin(user.email, body.password.old)) {\n      await updatePassword(user.email, body.password.new)\n    }\n    else {\n      return {status: 401 as const, result: \"Error: Incorrect password\" as const}\n    }\n  }\n\n  if(body.profile) {\n    let newData = await prisma.people.update({\n      where:{id: user.id},\n      data: {\n        display_name: body.profile.display_name,\n        link: body.profile.link,\n        bio: body.profile.bio,\n        pronouns: body.profile.pronouns\n      }\n    })\n    setHeaders = setTokenHeader({...user, display_name:newData.display_name, link: newData.link, bio: newData.bio})\n    await syncSSO({\n      external_id: user.id,\n      email: user.email,\n      username: user.username,\n      name: newData.display_name + (newData.pronouns ? `(${newData.pronouns})` : '') || '',\n      bio: newData.bio || '',\n      website: newData.link || ''\n    })\n  }\n\n  return {\n    status: 200,\n    result: '',\n    headers: setHeaders\n  } as const\n}\n\n\n\nasync function validateLogin(email: string, password: string):Promise<boolean> {\n  try {\n    let person = await prisma.people.findUnique({where:{email}})\n    if(!person) return false\n    return await bcrypt.compare(password, person.password_hash)\n  } catch (e) {\n    return false\n  }\n}\n\nasync function updatePassword(email: string, newPassword: string) {\n  let password_hash= await bcrypt.hash(newPassword, await bcrypt.genSalt())\n  await prisma.people.update({where:{email}, data:{password_hash}})\n}\nimport prisma from \"lib/prisma\";\n\nexport const profileDataQuery = (username: string, loggedIn: boolean)=>{\n  return prisma.people.findUnique({\n    where: {username: username},\n    select: {\n      stripe_connected_accounts: loggedIn,\n      calendar_id: loggedIn,\n      pronouns: true,\n      display_name: true,\n      bio: true,\n      link: true,\n    }\n  })\n}\n\nasync function getProfileData(req:Request) {\n  let username = req.query.id as string\n  let user = getToken(req)\n  if(!username) return {status: 400, result: 'ERROR: no user id provided'} as const\n  let data = await profileDataQuery(username, user?.username === username)\n  if(!data) return {status: 404, result: `Error: no user with id ${username} found`} as const\n  return {status: 200, result: data} as const\n}\n"]},"metadata":{},"sourceType":"module"}