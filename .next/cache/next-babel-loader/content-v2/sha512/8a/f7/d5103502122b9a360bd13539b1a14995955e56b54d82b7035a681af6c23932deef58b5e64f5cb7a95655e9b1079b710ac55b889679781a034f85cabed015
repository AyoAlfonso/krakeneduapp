{"ast":null,"code":"import { APIHandler } from 'src/apiHelpers';\nimport * as t from 'runtypes';\nimport { getToken } from 'src/token';\nimport prisma from \"lib/prisma\";\nexport default APIHandler({\n  POST: createEvent,\n  GET: getPublicEvents\n});\nlet CreateEventValidator = t.Intersect(t.Record({\n  start_date: t.String,\n  end_date: t.String,\n  description: t.String,\n  location: t.String,\n  name: t.String\n}), t.Union(t.Record({\n  type: t.Literal('cohort'),\n  cohort: t.Number,\n  people: t.Union(t.Undefined, t.Array(t.String))\n}), t.Record({\n  type: t.Literal('standalone'),\n  cost: t.Number,\n  max_attendees: t.Number\n})));\nexport const getPublicEventsQuery = () => prisma.standalone_events.findMany({\n  select: {\n    cost: true,\n    events: true,\n    event: true,\n    max_attendees: true,\n    standalone_events_in_courses: true\n  }\n});\n\nasync function getPublicEvents() {\n  let events = await getPublicEventsQuery();\n  return {\n    status: 200,\n    result: {\n      events\n    }\n  };\n}\n\nasync function createEvent(req) {\n  let msg;\n\n  try {\n    msg = CreateEventValidator.check(req.body);\n  } catch (e) {\n    return {\n      status: 400,\n      result: e.toString()\n    };\n  }\n\n  let user = getToken(req);\n  if (!user) return {\n    status: 401,\n    result: \"ERROR: no user logged in\"\n  };\n\n  switch (msg.type) {\n    case 'cohort':\n      {\n        let cohort = await prisma.course_cohorts.findUnique({\n          where: {\n            id: msg.cohort\n          },\n          select: {\n            cohort_facilitators: {\n              include: {\n                people: {\n                  select: {\n                    username: true\n                  }\n                }\n              }\n            },\n            people_in_cohorts: {\n              select: {\n                people: {\n                  select: {\n                    username: true\n                  }\n                }\n              }\n            }\n          }\n        });\n        if (!cohort) return {\n          status: 404,\n          result: `ERROR: no cohort with id ${msg.cohort} found`\n        };\n        if (!cohort.cohort_facilitators.find(f => user && f.facilitator === user.id) && !cohort.people_in_cohorts.find(p => user && p.people.username === user.username)) return {\n          status: 401,\n          result: \"ERROR: user is not enrolled or a facilitator of the cohort\"\n        };\n\n        if (msg.people) {\n          for (let username of msg.people) {\n            if (!cohort.people_in_cohorts.find(p => p.people.username === username) && cohort.cohort_facilitators.find(f => f.people.username === username)) return {\n              status: 400,\n              result: `ERROR: can't add person who is not part of the cohort or facilitator`\n            };\n          }\n        }\n\n        let event = await prisma.cohort_events.create({\n          include: {\n            events: {\n              include: {\n                people_in_events: {\n                  select: {\n                    people: {\n                      select: {\n                        username: true,\n                        display_name: true,\n                        id: true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          data: {\n            everyone: msg.people ? msg.people.length === 0 : true,\n            course_cohorts: {\n              connect: {\n                id: msg.cohort\n              }\n            },\n            events: {\n              create: {\n                people: {\n                  connect: {\n                    id: user.id\n                  }\n                },\n                people_in_events: !msg.people ? undefined : {\n                  create: msg.people.map(p => {\n                    return {\n                      people: {\n                        connect: {\n                          username: p\n                        }\n                      }\n                    };\n                  })\n                },\n                start_date: msg.start_date,\n                end_date: msg.end_date,\n                name: msg.name,\n                location: msg.location,\n                description: msg.description\n              }\n            }\n          }\n        });\n        return {\n          status: 200,\n          result: {\n            type: 'cohort',\n            event\n          }\n        };\n      }\n\n    case 'standalone':\n      {\n        let event = await prisma.standalone_events.create({\n          include: {\n            events: {\n              include: {\n                people_in_events: {\n                  select: {\n                    people: {\n                      select: {\n                        username: true,\n                        display_name: true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          data: {\n            cost: msg.cost,\n            max_attendees: msg.max_attendees,\n            events: {\n              create: {\n                people: {\n                  connect: {\n                    id: user.id\n                  }\n                },\n                start_date: msg.start_date,\n                end_date: msg.end_date,\n                name: msg.name,\n                location: msg.location,\n                description: msg.description\n              }\n            }\n          }\n        });\n        return {\n          status: 200,\n          result: {\n            type: 'standalone',\n            event\n          }\n        };\n      }\n  }\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/events/index.ts"],"names":["APIHandler","t","getToken","prisma","POST","createEvent","GET","getPublicEvents","CreateEventValidator","Intersect","Record","start_date","String","end_date","description","location","name","Union","type","Literal","cohort","Number","people","Undefined","Array","cost","max_attendees","getPublicEventsQuery","standalone_events","findMany","select","events","event","standalone_events_in_courses","status","result","req","msg","check","body","e","toString","user","course_cohorts","findUnique","where","id","cohort_facilitators","include","username","people_in_cohorts","find","f","facilitator","p","cohort_events","create","people_in_events","display_name","data","everyone","length","connect","undefined","map"],"mappings":"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","sourcesContent":["import { ResultType, APIHandler, Request} from 'src/apiHelpers'\nimport * as t from 'runtypes'\nimport { getToken } from 'src/token'\nimport prisma from \"lib/prisma\";\n\nexport default APIHandler({POST: createEvent, GET: getPublicEvents})\nexport type CreateEventMsg = t.Static<typeof CreateEventValidator>\nexport type CreateEventResponse = ResultType<typeof createEvent>\nexport type GetEventsResponse = ResultType<typeof getPublicEvents>\n\nlet CreateEventValidator = t.Intersect(t.Record({\n  start_date: t.String,\n  end_date: t.String,\n  description: t.String,\n  location: t.String,\n  name: t.String,\n}), t.Union(t.Record({\n  type: t.Literal('cohort'),\n  cohort: t.Number,\n  people: t.Union(t.Undefined, t.Array(t.String))\n}), t.Record({\n  type: t.Literal('standalone'),\n  cost: t.Number,\n  max_attendees: t.Number\n})))\n\nexport const getPublicEventsQuery = ()=>prisma.standalone_events.findMany({\n  select:{\n    cost: true,\n    events: true,\n    event: true,\n    max_attendees: true,\n    standalone_events_in_courses: true\n  }\n})\n\nasync function getPublicEvents() {\n  let events = await getPublicEventsQuery()\n  return {status: 200, result: {events}} as const\n}\n\nasync function createEvent(req:Request) {\n  let msg\n  try {msg = CreateEventValidator.check(req.body)}\n  catch(e) {return {status:400, result:e.toString()} as const }\n\n  let user = getToken(req)\n  if(!user) return {status: 401 , result: \"ERROR: no user logged in\"} as const\n\n  switch(msg.type){\n      case 'cohort': {\n        let cohort = await prisma.course_cohorts.findUnique({\n          where: {id: msg.cohort},\n          select:{\n            cohort_facilitators: {include:{people: {select:{username:true}}}},\n            people_in_cohorts: {select:{people: {select: {username: true}}}}\n          }})\n        if(!cohort) return {status: 404, result: `ERROR: no cohort with id ${msg.cohort} found`} as const\n\n        if(!cohort.cohort_facilitators.find(f=> user&&f.facilitator ===user.id) &&\n          !cohort.people_in_cohorts.find(p=>user&&p.people.username===user.username)) return {status: 401, result: \"ERROR: user is not enrolled or a facilitator of the cohort\"} as const\n        if(msg.people){\n          for(let username of msg.people) {\n            if(!cohort.people_in_cohorts.find(p=>p.people.username === username) &&\n              cohort.cohort_facilitators.find(f=>f.people.username===username)) return {status:400, result: `ERROR: can't add person who is not part of the cohort or facilitator`} as const\n          }\n        }\n\n        let event = await prisma.cohort_events.create({\n          include: {\n            events: {\n              include: {\n                people_in_events: {select:{people:{select:{username: true, display_name: true, id: true}}}},\n              }\n            }\n          },\n          data: {\n            everyone: msg.people ? msg.people.length === 0 : true,\n            course_cohorts: {\n              connect: {\n                id: msg.cohort\n              }\n            },\n            events: {\n              create: {\n                people:{connect:{id: user.id}},\n                people_in_events: !msg.people ? undefined : {\n                  create: msg.people.map(p=>{\n                    return {people:{connect:{username: p}}}\n                  })\n                },\n                start_date: msg.start_date,\n                end_date: msg.end_date,\n                name: msg.name,\n                location: msg.location,\n                description: msg.description,\n              }\n            }\n          }\n        })\n        return  {status: 200, result: {type: 'cohort', event}} as const\n      }\n      case 'standalone': {\n        let event = await prisma.standalone_events.create({\n          include: {\n            events: {\n              include: {\n                people_in_events: {select:{people:{select:{username: true, display_name: true}}}},\n              }\n            }\n          },\n          data: {\n            cost: msg.cost,\n            max_attendees: msg.max_attendees,\n            events: {\n              create: {\n                people:{connect:{id: user.id}},\n                start_date: msg.start_date,\n                end_date: msg.end_date,\n                name: msg.name,\n                location: msg.location,\n                description: msg.description,\n              },\n            }\n          }\n        })\n        return {status: 200, result: {type: 'standalone', event}} as const\n      }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}