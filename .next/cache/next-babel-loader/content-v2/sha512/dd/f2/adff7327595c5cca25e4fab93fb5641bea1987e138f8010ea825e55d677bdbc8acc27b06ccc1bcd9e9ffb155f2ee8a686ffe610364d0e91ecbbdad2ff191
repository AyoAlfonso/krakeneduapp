{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport bcrypt from 'bcryptjs';\nimport { v4 as uuidv4 } from 'uuid';\nimport hmac from '../../../src/hmac';\nimport { setTokenHeader } from '../../../src/token';\nimport { multiRouteHandler } from '../../../src/apiHelpers';\nimport { syncSSO } from '../../../src/discourse';\nimport { sendVerificationEmail } from '../../../emails';\nimport { usernameValidate } from 'src/utils';\nimport prisma from \"lib/prisma\";\nexport default multiRouteHandler('action', {\n  request: Signup,\n  verify: VerifyEmail,\n  newsletter: newsletterSignup\n});\n\nasync function Signup(req) {\n  let msg = req.body;\n\n  if (!msg.email || !msg.password || !msg.username || msg.newsletter === undefined) {\n    return {\n      status: 400,\n      result: 'Error: invalid message, missing email, password, newsletter, or display_name'\n    };\n  }\n\n  if (!usernameValidate(msg.username)) return {\n    status: 400,\n    result: \"Error: Username must be between 3 and 15 characters, and contain only numbers, letters, dots, dashes, and underscores\"\n  };\n\n  if (!(await checkUser(msg.email))) {\n    return {\n      status: 401,\n      result: \"Error: A user exists with that email\"\n    };\n  }\n\n  let salt = await bcrypt.genSalt();\n  let password_hash = await bcrypt.hash(msg.password, salt);\n  let key = await createActivationKey({\n    email: msg.email.toLowerCase(),\n    username: msg.username,\n    password_hash,\n    newsletter: msg.newsletter\n  });\n  let origin = new URL(req.headers.referer || '').origin;\n  let activation_url = `${origin}/signup?verifyEmail=${key}`;\n  await sendVerificationEmail(msg.email, {\n    activation_code: key,\n    name: msg.username,\n    activation_url\n  });\n  return {\n    status: 200,\n    result: ''\n  };\n}\n\nasync function VerifyEmail(req) {\n  let msg = req.body;\n  if (!msg.key) return {\n    status: 400,\n    result: 'Error: invalid message, missing property key'\n  };\n  let keyHash = hmac(msg.key);\n  let token = await getActivationKey(keyHash);\n  if (!token) return {\n    status: 403,\n    result: 'Error: invalid activation_key'\n  };\n  let date = new Date(token.created_time);\n\n  if ((Date.now() - date.getTime()) / (1000 * 60) > 30) {\n    return {\n      status: 403,\n      result: \"Error: activation_key is out of date\"\n    };\n  }\n\n  let id = await createUser({\n    username: token.username,\n    email: token.email,\n    password_hash: token.password_hash\n  });\n\n  if (token.newsletter) {\n    fetch('https://api.buttondown.email/v1/subscribers', {\n      method: \"POST\",\n      headers: {\n        Authorization: `Token ${process.env.BUTTONDOWN_API_KEY}`,\n        \"Content-Type\": 'application/json; charset=utf-8'\n      },\n      body: JSON.stringify({\n        email: token.email\n      })\n    });\n  }\n\n  if (!id) return {\n    status: 403,\n    result: \"Error: Couldn't create user. May already exist\"\n  };\n  await syncSSO({\n    external_id: \"7abd6904-73ed-4f33-b9b7-864a3e574c6a\",\n    username: \"pudakas\",\n    email: \"faryk@mailinator.com\"\n  });\n  return {\n    status: 200,\n    result: '',\n    headers: setTokenHeader({\n      id,\n      email: token.email,\n      username: token.username\n    })\n  };\n}\n\nconst createActivationKey = async person => {\n  let key = uuidv4();\n  await prisma.activation_keys.create({\n    data: _objectSpread(_objectSpread({}, person), {}, {\n      created_time: new Date(Date.now()).toISOString(),\n      key_hash: hmac(key)\n    })\n  });\n  return key;\n};\n\nconst checkUser = async email => {\n  return !(await prisma.people.findFirst({\n    where: {\n      email: {\n        equals: email,\n        mode: 'insensitive'\n      }\n    }\n  }));\n};\n\nconst createUser = async input => {\n  let previousEvents = await prisma.no_account_rsvps.findMany({\n    where: {\n      email: {\n        equals: input.email,\n        mode: 'insensitive'\n      }\n    }\n  });\n  let user;\n\n  try {\n    [user] = await Promise.all([prisma.people.create({\n      data: _objectSpread(_objectSpread({}, input), {}, {\n        id: uuidv4(),\n        people_in_events: {\n          create: previousEvents.map(ev => {\n            return {\n              events: {\n                connect: {\n                  id: ev.event\n                }\n              }\n            };\n          })\n        }\n      })\n    }), prisma.activation_keys.deleteMany({\n      where: {\n        email: input.email\n      }\n    }), previousEvents.length > 0 ? prisma.no_account_rsvps.deleteMany({\n      where: {\n        email: {\n          equals: input.email,\n          mode: 'insensitive'\n        }\n      }\n    }) : undefined]);\n  } catch (e) {\n    console.log(e);\n    return false;\n  }\n\n  return user.id;\n};\n\nconst getActivationKey = async hash => {\n  return prisma.activation_keys.findUnique({\n    where: {\n      key_hash: hash\n    },\n    select: {\n      username: true,\n      email: true,\n      password_hash: true,\n      created_time: true,\n      newsletter: true\n    }\n  });\n};\n\nasync function newsletterSignup(req) {\n  let msg = req.body;\n  if (!msg.email) return {\n    status: 400,\n    result: \"ERROR: no email provided\"\n  };\n  await fetch('https://api.buttondown.email/v1/subscribers', {\n    method: \"POST\",\n    headers: {\n      Authorization: `Token ${process.env.BUTTONDOWN_API_KEY}`,\n      \"Content-Type\": 'application/json; charset=utf-8'\n    },\n    body: JSON.stringify({\n      email: msg.email,\n      tags: ['homepage']\n    })\n  });\n  return {\n    status: 200,\n    result: 'Signed up for newsletter'\n  };\n}","map":{"version":3,"sources":["/Users/ayooluwaalfonso/code/krakeneduapp/pages/api/signup/[action].ts"],"names":["bcrypt","v4","uuidv4","hmac","setTokenHeader","multiRouteHandler","syncSSO","sendVerificationEmail","usernameValidate","prisma","request","Signup","verify","VerifyEmail","newsletter","newsletterSignup","req","msg","body","email","password","username","undefined","status","result","checkUser","salt","genSalt","password_hash","hash","key","createActivationKey","toLowerCase","origin","URL","headers","referer","activation_url","activation_code","name","keyHash","token","getActivationKey","date","Date","created_time","now","getTime","id","createUser","fetch","method","Authorization","process","env","BUTTONDOWN_API_KEY","JSON","stringify","external_id","person","activation_keys","create","data","toISOString","key_hash","people","findFirst","where","equals","mode","input","previousEvents","no_account_rsvps","findMany","user","Promise","all","people_in_events","map","ev","events","connect","event","deleteMany","length","e","console","log","findUnique","select","tags"],"mappings":"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","sourcesContent":["import bcrypt from 'bcryptjs'\nimport { v4 as uuidv4 } from 'uuid';\nimport hmac from '../../../src/hmac'\nimport {setTokenHeader} from '../../../src/token'\nimport {multiRouteHandler, ResultType, Request} from '../../../src/apiHelpers'\nimport {syncSSO} from '../../../src/discourse'\nimport {sendVerificationEmail} from '../../../emails'\nimport { usernameValidate } from 'src/utils';\nimport prisma from \"lib/prisma\";\n\nexport type SignupMsg = {\n  email: string\n  username: string\n  password: string\n  newsletter: boolean\n}\n\nexport type VerifyEmailMsg = {\n  key: string\n}\n\nexport type NewsletterSignupMsg = {email: string}\n\nexport type SignupResponse = ResultType<typeof Signup>\nexport type VerifyEmailResponse = ResultType<typeof VerifyEmail>\nexport type NewsletterSignupResponse = ResultType<typeof newsletterSignup>\n\nexport default multiRouteHandler('action', {\n  request: Signup,\n  verify: VerifyEmail,\n  newsletter: newsletterSignup\n})\n\nasync function Signup(req: Request) {\n  let msg: Partial<SignupMsg> = req.body\n  if(!msg.email || !msg.password || !msg.username || msg.newsletter === undefined) {\n    return {status: 400, result: 'Error: invalid message, missing email, password, newsletter, or display_name'} as const\n  }\n  if(!usernameValidate(msg.username)) return {status: 400, result: \"Error: Username must be between 3 and 15 characters, and contain only numbers, letters, dots, dashes, and underscores\"}\n\n  if(!(await checkUser(msg.email))) {\n    return {status:401, result: \"Error: A user exists with that email\"} as const\n  }\n\n  let salt = await bcrypt.genSalt()\n  let password_hash = await bcrypt.hash(msg.password, salt)\n\n  let key = await createActivationKey({email: msg.email.toLowerCase(), username:msg.username, password_hash, newsletter:msg.newsletter})\n\n  let origin = (new URL(req.headers.referer || '')).origin\n  let activation_url = `${origin}/signup?verifyEmail=${key}`\n\n  await sendVerificationEmail(msg.email, {activation_code: key, name:msg.username, activation_url})\n  return {status: 200, result: ''} as const\n}\n\nasync function VerifyEmail (req: Request) {\n  let msg: Partial<VerifyEmailMsg> = req.body\n  if(!msg.key) return {status: 400, result: 'Error: invalid message, missing property key'} as const\n\n  let keyHash = hmac(msg.key)\n  let token = await getActivationKey(keyHash)\n  if(!token) return {status: 403, result: 'Error: invalid activation_key'}\n\n  let date = new Date(token.created_time)\n\n  if((Date.now() - date.getTime())/(1000 * 60) > 30)  {\n    return {status: 403, result: \"Error: activation_key is out of date\"}\n  }\n\n  let id = await createUser({\n    username: token.username,\n    email: token.email,\n    password_hash: token.password_hash\n  })\n\n  if(token.newsletter) {\n    fetch('https://api.buttondown.email/v1/subscribers',{\n      method: \"POST\",\n      headers: {\n        Authorization: `Token ${process.env.BUTTONDOWN_API_KEY}`,\n        \"Content-Type\": 'application/json; charset=utf-8'\n      },\n      body: JSON.stringify({\n        email: token.email\n      })\n    })\n  }\n\n  if(!id) return {status: 403, result: \"Error: Couldn't create user. May already exist\"}\n\n  await syncSSO({\n    external_id: \"7abd6904-73ed-4f33-b9b7-864a3e574c6a\",\n    username: \"pudakas\",\n    email: \"faryk@mailinator.com\"\n  })\n\n  return {\n    status: 200,\n    result: '',\n    headers: setTokenHeader({id, email:token.email,username:token.username})\n  } as const\n}\n\nconst createActivationKey = async (person:{email: string, password_hash: string, username: string, newsletter:boolean}) => {\n  let key = uuidv4()\n  await prisma.activation_keys.create({\n    data: {\n      ...person,\n      created_time: new Date(Date.now()).toISOString(),\n      key_hash: hmac(key)\n    }\n  })\n  return key\n}\n\nconst checkUser = async (email:string):Promise<boolean> => {\n  return !(await prisma.people.findFirst({where: {email: {equals: email, mode: 'insensitive'}}}))\n}\n\n\nconst createUser = async (input:{email:string, password_hash:string, username: string}) => {\n  let previousEvents = await prisma.no_account_rsvps.findMany({where:{email: {equals: input.email, mode:'insensitive'}}})\n  let user\n  try {\n    [user] = await Promise.all([\n      prisma.people.create({\n        data:{\n          ...input,\n          id: uuidv4(),\n          people_in_events: {\n            create: previousEvents.map(ev=>{\n              return {\n                events: {connect: {id: ev.event}}\n              }\n            })\n          }\n        }\n      }),\n      prisma.activation_keys.deleteMany({where:{email:input.email}}),\n      previousEvents.length > 0 ? prisma.no_account_rsvps.deleteMany({where:{email: {equals: input.email, mode:'insensitive'}}}) : undefined\n    ])\n  } catch(e) {\n    console.log(e)\n    return false\n  }\n  return user.id\n}\n\nconst getActivationKey = async (hash: string)=> {\n  return prisma.activation_keys.findUnique({\n    where: {key_hash: hash},\n    select: {username: true, email: true, password_hash: true, created_time: true, newsletter: true}\n  })\n}\n\nasync function newsletterSignup (req: Request) {\n  let msg = req.body as Partial<NewsletterSignupMsg>\n  if(!msg.email) return {status: 400, result: \"ERROR: no email provided\"} as const\n\n  await fetch('https://api.buttondown.email/v1/subscribers',{\n    method: \"POST\",\n    headers: {\n      Authorization: `Token ${process.env.BUTTONDOWN_API_KEY}`,\n      \"Content-Type\": 'application/json; charset=utf-8'\n    },\n    body: JSON.stringify({\n      email: msg.email,\n      tags: [\n        'homepage'\n      ]\n    })\n  })\n  return {status:200, result: 'Signed up for newsletter'}\n}\n"]},"metadata":{},"sourceType":"module"}